##                                                                    Redis

### 1.Redis为什么快？

Redis 之所以运行比较快的原因有以下几个：

1. **数据存储在内存中**：Redis 的数据存储在内存中，而内存的读写速度远远快于硬盘。这使得 Redis 能够实现非常快速的读写操作。
2. **单线程处理请求**：Redis 是单线程的，因此可以避免线程切换和锁竞争等问题，提高了 CPU 的利用率和性能。
3. **高效的数据结构**：Redis 提供了多种高效的数据结构，如哈希表、有序集合等，这些数据结构能够快速地进行插入、删除、查找和排序等操作。
4. **异步 I/O**：Redis 使用异步 I/O 技术，可以在等待客户端输入或输出时继续处理其他请求，从而提高了系统的吞吐量。
5. **高效的持久化机制**：Redis 提供了多种持久化机制，如 RDB、AOF 和混合持久化机制，这些机制运行都非常高效，可以在不影响性能的情况下保证数据的安全。

综上所述，Redis 之所以快速，是因为它综合运用了多种优秀的技术和算法，并且针对内存数据库场景做了很多优化。

### 2.Redis可以实现什么功能？

Redis 是一个开源的基于内存的数据结构存储系统，可以实现以下功能：

1. **缓存**：Redis 可以作为缓存系统，将热点数据存储在内存中，提高读写性能和响应速度，减少对后端数据存储的压力。
2. **消息队列**：Redis 的发布订阅功能和 List 数据结构可以实现消息队列的功能，实现异步处理任务、解耦系统组件之间的依赖关系等。
3. **计数器和排行榜**：Redis 的原子操作和 Sorted Set 数据结构可以实现计数器和排行榜的功能，支持快速地增加、减少和排序操作。
4. **分布式锁**：Redis 的 SETNX 命令可以实现分布式锁，避免多个客户端同时修改同一个数据，保证数据的一致性和正确性。
5. **分布式会话管理**：Redis 可以存储会话信息，实现分布式会话管理，支持会话的共享和迁移等功能。

### 3.Redis有哪些数据类型？

Redis 常用的数据类型有 5 种：String 字符串类型、List 列表类型、Hash 哈希表类型、Set 集合类型、Sorted Set 有序集合类型，如下图所示： ![image.png](https://javacn.site/image/1673429563314-89662316-5e2c-4bf0-a07a-d8426b491da2.png) 这 5 种常用类型的用途如下：

1. String（字符串类型）常见使用场景是：存储 Session 信息、存储缓存信息（如详情页的缓存）、存储整数信息，可使用 incr 实现整数+1，和使用 decr 实现整数 -1；
2. List（列表类型）常见使用场景是：实现简单的消息队列、存储某项列表数据；
3. Hash（哈希表类型）常见使用场景是：存储 Session 信息、存储商品的购物车，购物车非常适合用哈希字典表示，使用人员唯一编号作为字典的 key，value 值可以存储商品的 id 和数量等信息、存储详情页信息；
4. Set（集合类型）是一个无序并唯一的键值集合，它的常见使用场景是：关注功能，比如关注我的人和我关注的人，使用集合存储，可以保证人员不会重复；
5. Sorted Set（有序集合类型）相比于 Set 集合类型多了一个排序属性 score（分值），它的常见使用场景是：可以用来存储排名信息、关注列表功能，这样就可以根据关注实现排序展示了。

### 4.有序集合底层是如何实现的？

有序集合类型 (Sorted Set) 相比于集合类型多了一个排序属性 score（分值），对于有序集合 ZSet 来说，每个存储元素相当于有两个值组成的，一个是有序结合的元素值，一个是排序值。有序集合的存储元素值也是不能重复的，但分值是可以重复的，如下图所示： ![img](https://javacn.site/image/1683162474601-2d2e8c2f-7c47-441d-a9ad-f7ed595832e5.png)

**有序集合是由 ziplist (压缩列表) 或 skiplist (跳跃表) 组成的。**

1. 压缩列表 ziplist 本质上就是一个字节数组，是 Redis 为了节约内存而设计的一种线性数据结构，可以包含多个元素，每个元素可以是一个字节数组或一个整数。
2. 跳跃表 skiplist 是一种有序数据结构，它通过在每个节点中维持多个指向其他节点的指针，从而达到快速访问节点的目的。跳跃表支持平均 O(logN)、最坏 O(N) 复杂度的节点查找，还可以通过顺序性操作来批量处理节点。

当数据比较少时，有序集合是压缩列表 ziplist 存储的，反之则为跳跃表 skiplist 存储，使用压缩列表存储必满足以下两个条件：

1. 有序集合保存的元素个数要小于 128 个；
2. 有序集合保存的所有元素成员的长度都必须小于 64 字节。

如果不能满足以上两个条件中的任意一个，有序集合将会使用跳跃表 skiplist 结构进行存储。

### 5.跳跃表底层是如何实现的？

跳跃表的底层是由 C 语言实现的，它的实现源码如下：



```c
typedef struct zskiplistNode {
	// 成员对象
    robj *obj;
    double score; // 分值
    struct zskiplistNode *backward; // 回退指针
    //层
    struct zskiplistLevel {
    	// 前进指针
        struct zskiplistNode *forward;
        // 跨度
        unsigned int span;
    } level[];
} zskiplistNode;
```

- obj：用于存储字符串类型的数据；
- score：用于存储排序的分值；
- backward：后退指针，只能指向当前节点最底层的前一个节点，头节点和第一个节点 backward 指向 NULL，从后向前遍历跳跃表时使用；
- level：柔性数组。每个节点的数组长度不一样，在生成跳跃表节点时，随机生成一个 1-64 的值，值越大出现的概率越低。level 数组的每项包含以下两个元素： 
  - forward：指向本层下一个节点，尾节点的 forward 指向 NULL；
  - span：forward 指向的节点与本节点之间的元素个数，span 值越大，跳过的节点个数越多。

除了跳跃表节点外，还需要一个跳跃表结构来管理节点，Redis 使用 zskiplist 结构体，定义如下：



```c
typedef struct zskiplist {
    struct zskiplistNode *header, *tail;
    unsigned long length;
    int level;
} zskiplist;
```

- header：指向跳跃表头节点。头节点是跳跃表的一个特殊节点，它的 level 数组元素个数为 64。头节点在有序集合中不存储任何 member 和 score 值，ele 值为 NULL, score 值为 0，也不计入跳跃表的总长度。头节点在初始化时，64 个元素的 forward 都指向 NULL,span 值都为 0；
- tail：指向跳跃表尾节点；
- length：跳跃表长度，表示除头节点之外的节点总数；
- level：跳跃表的高度。

它的结构实现如下图所示： ![image.png](https://javacn.site/image/1673579856689-12af8410-614d-47d0-8712-00cf52f4aac9.png)



### 6.Redis如何实现消息队列？

Redis 实现消息队列的常见方法有两种：使用 Redis 中提供的发布订阅（Pub/Sub）功能或 List 数据结构。

具体实现方法如下：

1. 发布订阅（Pub/Sub）：Redis 的发布订阅功能可以实现消息队列的发布和订阅功能。生产者将消息发布到指定的通道（channel）中，消费者可以订阅该通道，接收并处理消息。该模式支持一对多的消息传递，一个消息可以被多个消费者接收，也可以实现分组订阅，将不同的消费者分为不同的组，实现广播或点对点的消息传递。
2. List 数据结构：Redis 的 List 数据结构可以实现消息队列的入队和出队操作。生产者将消息插入到 List 的尾部，消费者从 List 的头部获取消息，实现先进先出（FIFO）的消息处理。可以使用阻塞式的 POP 操作来实现消费者等待新消息到达，也可以使用定时轮询的方式来获取新消息。

#### [#](#发布订阅-vs-list) 发布订阅 VS List

发布订阅和 List 的特点如下：

- 发布订阅：发布订阅是一种一对多的消息传递方式，即一个消息可以被多个消费者同时接收。生产者发布消息到指定的通道，消费者订阅该通道，接收并处理消息。如果消费者在消息发布之前订阅了该通道，则可以接收到该消息；如果在消息发布后才订阅，则无法接收到之前的消息。发布订阅模式适用于广播或点对点的消息传递，但是无法保证消息的顺序。
- List 数据结构：List 数据结构是一种先进先出（FIFO）的消息传递方式，即消息入队列时在队列尾部添加，消息出队列时从队列头部删除。生产者将消息插入到 List 的尾部，消费者从 List 的头部获取消息。可以使用阻塞式的 POP 操作来实现消费者等待新消息到达，也可以使用定时轮询的方式来获取新消息。List 模式适用于需要按顺序处理消息的场景，但是不适用于广播消息传递。

它们的区别如下：

- 发布订阅：优点是可以实现一对多的消息传递，支持分组订阅和模式匹配订阅；缺点是无法保证消息的顺序和可靠性，消费者无法感知到生产者是否已经处理完该消息。
- List 数据结构：优点是可以保证消息的顺序和可靠性，消费者可以在处理完一个消息后再获取下一个消息；缺点是不适用于一对多的消息传递。

#### [#](#小结) 小结

综上所述，发布订阅和 List 数据结构都可以用来实现消息队列，但适用的场景不同，需要根据实际业务需求来选择。如果需要广播或点对点的消息传递，可以选择发布订阅；如果需要按顺序处理消息，可以选择 List 数据结构。

### 7.Redis如何实现分布式锁？

Redis 作为一个独立的三方系统（通常被作为缓存中间件使用），其天生的优势就是可以作为一个分布式系统来使用，因此使用 Redis 实现的锁都是分布式锁，如下图所示：

![img](https://javacn.site/image/1683185756826-1f999aa8-9cbe-4f34-9c4e-8c338f16f876.png)

在 Redis 中实现分布式锁可以使用 SETNX 和 EXPIRE 命令来实现，SETNX 是 "SET if Not eXists" 的缩写，是一个原子性操作，用于在指定的 key 不存在时设置 key 的值。如果 key 已经存在，SETNX 操作将不做任何事情，返回失败；如果 key 不存在，SETNX 操作会设置 key 的值，并返回成功。而 EXPIRE 是设置锁的过期时间的，主要为了防止死锁的发生，SETNX + EXPIRE 的实现命令如下：

![img](https://javacn.site/image/1683186275970-c3d1a02c-0a09-4508-b7b7-1531c3620497.png)

其中“nx”表示 not exists 不存在则设置 key，“ex 10”表示过期时间为 10 秒，“mylock”值为 key，“lock”值为 value。

#### [#](#分布式锁问题) 分布式锁问题

SETNX 和 EXPIRE 一起使用可以实现分布式锁的功能，但存在锁误删的问题，比如线程 1 设置的过期时间为 5s，而线程 1 执行了 7s，那么在第 5s 之后锁过期了，那么其他线程就可以拥有这把锁了，之后线程 1 执行完业务，又执行了锁删除操作，那么此时锁就被误删了。

#### [#](#解决方案) 解决方案

此时可以每个锁的 value 中添加拥有者的标识，删除之前先判断是否是自己的锁，如果是则删除，否则不删除。但是判断和删除之间不是原子性操作，所以依然有问题。此时可以使用 lua 脚本来判断并删除锁，lua 脚本可以保证 redis 中多条语句执行的原子性，所以就可以解决此问题了。

> PS：如果觉得自己实现 lua 脚本比较麻烦，可以使用 Redisson 框架来实现分布式锁。它通过简单 API 可以实现分布式锁，并且没有上述问题，它的底层也是通过 lua 脚本来实现的，只不过框架已经帮开发者封装好了，这样开发者就可以把更多精力放在业务上，而无序担心分布式锁的操作问题了。

### 8.Redis如何保证数据不丢失？

Redis 中的数据是存放在内存中的，这样可以保证 Redis 高效的运行，然而内存中的数据会随着系统的重启而丢失，那么 Redis 是如何保证数据不丢失的呢？

Redis 保证数据不丢失的手段是持久化，持久化是指将 Redis 内存中的数据存储到磁盘，以便 Redis 重启时能够从磁盘中恢复原有的数据，而整个过程就叫做 Redis 持久化，也就是说 **Redis 使用了“持久化”技术来保证 Redis 中的数据不丢失**。

Redis 持久化有以下 3 种实现方式：

1. 快照方式（RDB, Redis DataBase）将某一个时刻的内存数据，以二进制的方式写入磁盘；
2. 文件追加方式（AOF, Append Only File），记录所有的操作命令，并以文本的形式追加到文件中；
3. 混合持久化方式，Redis 4.0 之后新增的方式，混合持久化是结合了 RDB 和 AOF 的优点，在写入的时候，先把当前的数据以 RDB 的形式写入文件的开头，再将后续的操作命令以 AOF 的格式存入文件，这样既能保证 Redis 重启时的速度，又能减低数据丢失的风险。

### 9.RDB和AOF有什么区别？

RDB（Redis DataBase）和 AOF（Append Only File）是 Redis 中两种不同的持久化机制，它们有以下几点区别：

1. 写入方式：RDB 是通过快照（snapshot）机制，将 Redis 中的数据集以二进制文件的方式写入硬盘；AOF 则是通过将 Redis 服务器执行的所有写命令（例如 set、del、incrby 等）记录在 AOF 文件中，写入方式是追加写入。
2. 数据恢复：当 Redis 重启时，可以根据 RDB 文件或 AOF 文件来恢复数据。恢复 RDB 文件比恢复 AOF 文件快，因为 RDB 文件包含了一个时间点上的快照，可以直接将整个数据集加载到内存中。而恢复 AOF 文件则需要逐条执行文件中记录的命令，需要更长的时间。
3. 数据完整性：RDB 文件保存的是 Redis 在某个时间点的数据快照，如果 Redis 在快照操作之后宕机，可能会丢失最后一次快照后的数据。而 AOF 文件记录了 Redis 所有的写命令，因此即使 Redis 宕机，也可以根据 AOF 文件恢复数据。
4. 文件大小：RDB 文件通常比 AOF 文件小，因为它只保存了一个时间点的数据快照，而 AOF 文件保存了所有的写命令，会比 RDB 文件大。
5. 性能影响：AOF 文件追加写入方式可能会降低 Redis 的写性能，但可以提供更好的数据安全性，而 RDB 文件在进行快照时可能会阻塞 Redis 的服务。

### 10.Redis过期策略有哪些？

Redis 中的过期删除策略是指在键（key）上设置了过期时间后，Redis 在某个条件触发时会自动删除过期的键。

Redis 中有两种过期删除策略：

1. 定期删除策略（定时任务方式）：Redis 会定期地（默认每秒钟检查 10 次）随机抽取一部分设置了过期时间的键，检查它们是否过期，如果过期则删除。该策略可以通过配置文件中的 hz 参数进行调整。
2. 惰性删除策略（懒汉式方式）：当访问一个键时，Redis 会先检查该键是否过期，如果过期则删除。这意味着过期键可能会在访问时被删除，而不是在过期时立即删除。

Redis 定期删除策略并不会遍历删除每个过期键，而是采用随机抽取的方式删除过期键，同时为了保证过期扫描不影响 Redis 主业务，Redis 的定期删除策略中还提供了最大执行时间，以保证 Redis 正常并高效的运行。

#### [#](#关于-hz) 关于“hz”

在 Redis 中，"hz" 是 "hertz" 的缩写。Hertz 是国际单位制中表示频率的单位，表示每秒钟发生的周期数或事件发生的次数。在 Redis 中，"hz" 参数用于表示每秒钟执行定期删除策略的次数，即每秒钟检查过期键的频率。 默认 hz 配置如下图所示： ![image.png](/image/1683363015966-4d685eee-9217-4567-a88d-dfd0961dac49.png) 可以编辑 Redis 的配置文件 redis.conf，找到并修改以下参数来调整定期删除策略：



```text
hz <value>
```

默认情况下，hz 参数的值为 10，表示每秒钟进行 10 次检查。可以根据需要增加或减少该值来调整定期删除的频率。例如，将 hz 的值设置为 5，表示每秒钟进行 5 次检查。

修改完成后，保存配置文件并重启 Redis 服务器使配置生效。

### 11.说一下定期删除的流程？

Redis 定期删除流程如下：

1. 从设置了过期时间的字典中随机取出 20 个键；
2. 删除这 20 个键中过期的键；
3. 如果过期 key 的比例超过 25% ，重复步骤 1。

同时为了保证过期扫描不会出现循环过度，导致线程卡死现象，算法还增加了扫描时间的上限，默认不会超过 25ms。 定期删除执行流程，如下图所示： ![image.png](https://javacn.site/image/1683366244172-f432b9c5-71b3-4ac4-a5f9-7696975bf3b9.png)



### 12.Redis内存会被用完吗？

当 Redis（运行）内存被使用完时，也就是当 Redis 的运行内存，已经超过 Redis 设置的最大内存之后，**Redis 将采用内存淘汰机制来删除符合条件的键值对，以此来保障 Redis 的正常运行**。

#### [#](#内存淘汰策略) 内存淘汰策略

早期版本的 Redis 有以下 6 种淘汰机制（也叫做内存淘汰策略）：

1. noeviction：不淘汰任何数据，当内存不足时，新增操作会报错，Redis 默认内存淘汰策略；
2. allkeys-lru：淘汰整个键值中最久未使用的键值；
3. allkeys-random：随机淘汰任意键值；
4. volatile-lru：淘汰所有设置了过期时间的键值中最久未使用的键值；
5. volatile-random：随机淘汰设置了过期时间的任意键值；
6. volatile-ttl：优先淘汰更早过期的键值。

在 Redis 4.0 版本中又新增了 2 种淘汰机制：

1. volatile-lfu：淘汰所有设置了过期时间的键值中，最少使用的键值；
2. allkeys-lfu：淘汰整个键值中最少使用的键值。

其中 allkeys-xxx 表示从所有的键值中淘汰数据，而 volatile-xxx 表示从设置了过期键的键值中淘汰数据。 所以，现在 Redis 的版本中有 8 种内存淘汰策略。

#### [#](#查看内存淘汰策略) 查看内存淘汰策略

![image.png](https://javacn.site/image/1683367862648-96466a29-4066-4570-901f-2937c2f6d534.png)

#### [#](#设置内存淘汰策略) 设置内存淘汰策略

Redis 内存淘汰策略有两种设置方式：

1. 修改 redis 配置文件设置内存淘汰策略；
2. 连接 redis 服务器，通过命令设置内存淘汰策略。

具体设置执行如下。

#### [#](#设置配置文件) 设置配置文件

通过 redis 的配置文件 redis.conf 来设置内存淘汰策略：



```text
maxmemory-policy allkeys-lru
```

#### [#](#通过命令设置) 通过命令设置

先连接到 redis 服务器，然后通过命令修改淘汰策略：



```text
127.0.0.1:6379> config set maxmemory-policy allkeys-lru
```

注意事项：通过命令设置内存淘汰策略，在 redis 重启之后会失效，所以最好是在配置文件中设置内存淘汰策略。

### 13.什么情况下会执行内存淘汰策略？

Redis 内存淘汰策略会在以下情况下被触发：

1. 写操作时内存超过限制：当 Redis 内存使用量超过了设置的 maxmemory 参数所定义的限制时，写操作（例如 set、hset 等）会触发内存淘汰策略。Redis 会根据设置的淘汰策略来删除一些键值对，以释放内存空间来容纳新的数据。
2. 启用 AOF 重写：如果 Redis 使用了 AOF（Append Only File）持久化方式，并且开启了 AOF 重写功能，那么在执行 AOF 重写过程中也会触发内存淘汰策略。AOF 重写是将 AOF 文件重写为一种更紧凑、更快速加载的格式，这个过程中会使用更少的内存来存储数据。
3. 通过命令主动释放内存：Redis 也可以通过主动执行 MEMORY PURGE 命令来释放内存。

#### [#](#查看运行最大内存) 查看运行最大内存

可以通过命令“config get maxmemory”查询 Redis 能使用的最大内存值： ![image.png](/image/1683368421486-b22d057d-1fde-45cc-b281-3904f14766b3.png) 在不设置 Redis 具体的最大内存值大小时，或者设置最大内存大小为 0 时，在 64 位操作系统下不限制内存大小，在 32 位操作系统下最多使用 3GB 内存。

#### [#](#设置运行最大内存) 设置运行最大内存

设置 Redis 运行最大内存有以下两种方式。

1.通过 Redis 配置文件 redis.conf 设置内存大小：



```java
// 设置 Redis 最大占用内存大小为 100M
maxmemory 100mb
```

2.通过命令行设置 Redis 最大占用内存大小：

> 127.0.0.1:6379> config set maxmemory 100mb

### 14.LRU和LFU有什么区别？

LRU（Least Recently Used，最近最少使用）和LFU（Least Frequently Used，最不常使用）都是常见的缓存淘汰策略，它们在选择淘汰缓存中的键时有不同的侧重点。

1. LRU（最近最少使用）：LRU 策略基于时间的概念，它认为最近被访问过的键是最有可能被再次访问的，因此在淘汰时会优先选择最久未被访问的键。LRU 策略会维护一个访问顺序列表，每当一个键被访问时，它会被移动到列表的末尾，最近没有被访问的键会位于列表的前面。当需要淘汰键时，LRU 策略会选择列表前面的键进行淘汰。
2. LFU（最不常使用）：LFU 策略基于访问频率的概念，它认为被访问次数最少的键是最不常用的，因此在淘汰时会优先选择访问次数最少的键。LFU 策略会为每个键维护一个访问计数器，每当一个键被访问时，其计数器会增加。当需要淘汰键时，LFU 策略会选择访问计数最低的键进行淘汰。

主要区别：

- LRU 是基于时间的策略，LFU 是基于访问频率的策略。
- LRU 策略假设最近被访问的键最有可能再次被访问，LFU 策略假设被访问次数最少的键是最不常用的。
- LRU 维护一个访问顺序列表，LFU 维护一个访问计数器。
- LRU 只关注键的访问顺序，而 LFU 关注键的访问频率。

选择使用哪种策略取决于具体的应用场景和访问模式。如果应用对最近访问的数据比较敏感，LRU 可能更适合；如果应用对访问频率较低的数据更感兴趣，LFU 可能更合适。有些缓存系统也采用 LRU 和 LFU 的结合策略，根据具体情况灵活选择淘汰键。

### 15.什么是缓存雪崩？如何解决？

缓存雪崩是指在缓存中大量的键同时过期或失效，导致请求直接访问数据库或后端服务，给数据库或后端服务造成巨大压力，导致系统性能下降甚至崩溃的现象。

缓存雪崩可能发生的原因包括：

1. 大量缓存键同时过期：当缓存键设置了相同的过期时间，或者由于某种原因导致大量的键同时失效，会导致缓存雪崩。
2. 缓存服务器故障：当缓存服务器发生故障，无法提供服务时，请求将直接访问后端服务，导致压力集中在后端服务上。

为了解决缓存雪崩问题，可以采取以下策略：

1. 设置随机过期时间：为缓存键设置随机的过期时间，避免大量键同时过期的情况发生，减少缓存雪崩的概率。
2. 实现缓存预热：在系统启动或缓存失效前，提前加载热门数据到缓存中，避免在关键时刻大量请求直接访问后端服务。
3. 使用分布式缓存：将缓存数据分布在多个缓存节点上，通过分散请求负载来减少单个缓存节点的压力，提高系统的可用性和抗压能力。
4. 设置熔断机制：在缓存失效的情况下，通过设置熔断机制，直接返回默认值或错误信息，避免请求直接访问后端服务，减轻后端服务的压力。
5. 实时监控和报警：监控缓存系统的状态和性能指标，及时发现异常情况，并通过报警机制通知运维人员进行处理，减少缓存雪崩的影响。

### 16.什么是缓存穿透，如何解决？

缓存穿透是指在缓存系统中，大量的请求查询不存在于缓存和数据库中的数据，导致这些请求直接访问数据库，占用数据库资源，而缓存无法发挥作用的现象。

缓存穿透可能发生的原因包括：

1. 恶意请求（异常情况）：攻击者发送大量恶意请求，故意查询不存在的数据，以触发缓存穿透。
2. 高并发请求（正常业务）：当有大量的并发请求同时查询不存在的数据时，可能会导致缓存无法命中，从而触发缓存穿透。

为了解决缓存穿透问题，可以采取以下策略：

1. 布隆过滤器（Bloom Filter）：布隆过滤器是一种高效的数据结构，可以用于快速判断一个元素是否存在于集合中。在缓存层引入布隆过滤器，可以在查询请求到达时，首先通过布隆过滤器判断该请求对应的数据是否存在于缓存或数据库中，从而避免无效的查询操作。
2. 缓存空值处理：对于查询数据库返回的空结果，也可以将空结果缓存起来，设置一个较短的过期时间，避免频繁查询数据库。这样在下次查询相同的数据时，可以直接从缓存中获取空结果，而不需要再次查询数据库。
3. 异步加载缓存：当缓存未命中时，可以异步加载数据到缓存中，避免在高并发场景下直接访问数据库。在异步加载过程中，可以通过互斥锁或分布式锁来保证只有一个线程去加载数据，避免重复加载。
4. 设置热点数据永不过期：对于一些热点数据，可以将其设置为永不过期，或者过期时间较长，以保证这部分数据始终在缓存中可用。
5. 限制恶意请求：通过访问频率控制、验证码等手段，限制对缓存的恶意请求，防止攻击者通过查询不存在的数据来触发缓存穿透。

### 17.什么是缓存击穿？如何解决？

缓存击穿是指在缓存系统中，某个热点数据过期或失效时，同时有大量的请求访问该数据，导致请求直接访问数据库或后端服务，给数据库或后端服务造成巨大压力，导致系统性能下降甚至崩溃的现象。

缓存击穿可能发生的原因包括：

1. 热点数据失效：当某个热点数据过期时，此时大量请求访问该数据，导致缓存失效，请求直接访问数据库。
2. 并发访问热点数据：在高并发环境下，大量的请求同时访问同一个热点数据，导致该热点数据在缓存失效期间被并发地访问，触发缓存击穿。

为了解决缓存击穿问题，可以采取以下策略：

1. 设置热点数据永不过期或过期时间较长：对于一些热点数据，可以将其设置为永不过期，或者设置一个较长的过期时间，确保热点数据在缓存中可用，减少因为过期而触发的缓存击穿。
2. 加互斥锁或分布式锁：在访问热点数据时，可以引入互斥锁或分布式锁，保证只有一个线程去访问后端服务或数据库，其他线程等待结果。当第一个线程获取到数据后，其他线程可以直接从缓存获取，避免多个线程同时访问后端服务，减轻压力。
3. 限制并发访问：通过限制并发访问热点数据的请求量，可以控制请求的流量，避免过多请求同时访问热点数据。

### 18.缓存雪崩和缓存击穿有什么区别？

缓存雪崩和缓存击穿是两种不同的缓存失效现象，它们在触发条件和影响范围上有所不同。

缓存雪崩（Cache Avalanche）：

- 触发条件：缓存雪崩是指在缓存系统中，大量的缓存键同时失效或过期，导致请求直接访问数据库或后端服务的现象。
- 影响范围：缓存雪崩会影响整个缓存系统，所有受影响的请求都会直接访问数据库或后端服务，导致数据库负载剧增，系统性能下降甚至崩溃。

缓存击穿（Cache Penetration）：

- 触发条件：缓存击穿是指在缓存系统中，某个热点数据失效或过期时，大量的请求同时访问该数据，导致请求直接访问数据库或后端服务的现象。
- 影响范围：缓存击穿通常只影响到热点数据，其他数据仍然可以从缓存中获取。只有在热点数据失效期间，才会触发大量请求访问数据库或后端服务。

主要区别：

- 触发条件不同：缓存雪崩是大量缓存键同时失效或过期，缓存击穿是针对某个热点数据失效或过期。
- 影响范围不同：缓存雪崩影响整个缓存系统，所有请求都受到影响；缓存击穿通常只影响到热点数据，其他数据仍可从缓存中获取。
- 对后端服务的影响不同：缓存雪崩会给后端服务带来巨大压力，导致性能下降甚至崩溃；缓存击穿只在热点数据失效期间对后端服务产生压力。

解决方法也不完全相同：

- 缓存雪崩的解决方法包括：合理设置缓存过期时间，引入热点数据永不过期、缓存预热、分布式缓存等策略。
- 缓存击穿的解决方法包括：设置热点数据永不过期或过期时间较长，加互斥锁或分布式锁，异步加载缓存等策略。

虽然缓存雪崩和缓存击穿都是缓存失效相关的问题，但它们的触发条件、影响范围和解决方法有所区别

### 19.Redis有集群吗？

Redis 有集群（功能），它的多机部署有以下 3 种：

1. 主从同步：主从同步 (主从复制) 是 Redis 高可用服务的基石，也是多机运行中最基础的一个。我们把主要存储数据的节点叫做主节点 (master)，把其他通过复制主节点数据的副本节点叫做从节点 (slave)。在 Redis 中一个主节点可以拥有多个从节点，一个从节点也可以是其他服务器的主节点；
2. 哨兵模式：哨兵模式 Redis Sentinel 是 Redis 的一种运行模式，它专注于对 Redis 实例（主节点、从节点）运行状态的监控，并能够在主节点发生故障时通过一系列的机制实现选主及主从切换，实现故障转移，确保整个 Redis 系统的可用性；
3. 集群模式：集群模式 Redis Cluster 是 Redis 3.0 版本推出的 Redis 集群方案，它将数据分布在不同的服务区上，以此来降低系统对单主节点的依赖，并且可以大大的提高 Redis 服务的读写性能。

## [#](#区别) 区别

主从同步是多机部署最简单的方案，也是存在问题最多的一个方案，它的优点是实现成本低，而这种模式本身存在一个致命的问题，当主节点奔溃之后，需要人工干预才能恢复 Redis 的正常使用。

例如，我们有 3 台服务器做了主从复制，一个主服务器 A 和两个从服务器 B、C，当 A 发生故障之后，需要人工把 B 服务器设置为主服务器，同时再去 C 服务器设置成从服务器并且从主服务器 B 同步数据，如果是发生在晚上或者从服务器节点很多的情况下，对于人工来说想要立即实现恢复的难度很多，所以我们需要一个自动的工具——Redis Sentinel (哨兵模式) 来把手动的过程变成自动的，让 Redis 拥有自动容灾恢复 (failover) 的能力。 哨兵模式如下所示：

![img](https://javacn.site/image/1673606071909-febf3c7d-ec6f-4ea8-b952-f184bdca8044.png)

哨兵模式专注于对 Redis 实例（主节点、从节点）运行状态的监控，并能够在主节点发生故障时通过一系列的机制实现选主及主从切换，实现故障自动转移和恢复，确保整个 Redis 系统的可用性，所以**哨兵模式相比于主从同步多个一个自动容灾恢复的优点**。 **无论是主从还是哨兵模式，它的性能扩展都是有限的，因为主节点只能有一个，而集群模式可以实现多个集群、多主节点的平行扩展**，如下图所示：

![img](https://javacn.site/image/1673606256649-f49d2d65-c445-42d2-82e0-0baed60142f0.png)

并且**集群模式也具备自动容灾恢复、自主选主的功能，所以集群模式才是 Redis 多机部署的最终形态**。

### 20.Redis优化方案有哪些？

想要更好的发挥 Redis 的性能，我们可以通过以下手段来实现。

#### [#](#_1-缩短键值对的存储长度) 1.**缩短键值对的存储长度**

在 key 不变的情况下，value 值越大操作效率越慢，因为 Redis 对于同一种数据类型会使用不同的内部编码进行存储，比如字符串的内部编码就有三种：int（整数编码）、raw（优化内存分配的字符串编码）、embstr（动态字符串编码），这是因为 Redis 的作者是想通过不同编码实现效率和空间的平衡，然而数据量越大使用的内部编码就越复杂，而越是复杂的内部编码存储的性能就越低。

#### [#](#_2-使用-lazy-free-延迟删除-特性) 2.使用 lazy free（延迟删除）特性

lazy free 特性是 Redis 4.0 新增的一个非常实用的功能，它可以理解为惰性删除或延迟删除。意思是在删除的时候提供异步延时释放键值的功能，把键值释放操作放在 BIO(Background I/O) 单独的子线程处理中，以减少删除删除对 Redis 主线程的阻塞，可以有效地避免删除 big key 时带来的性能和可用性问题。

在 Redis 配置文件 redis.conf 中开启 lazy free：



```xml
# 开启lazy free机制
lazyfree-lazy-eviction yes
```

#### [#](#_3-设置合理的过期时间) 3.设置合理的过期时间

我们应该根据实际的业务情况，对键值设置合理的过期时间，这样 Redis 会帮你自动清除过期的键值对，以节约对内存的占用，以**避免键值过多的堆积，频繁的触发内存淘汰策略**。

#### [#](#_4-禁用长耗时的查询命令) 4.禁用长耗时的查询命令

生产环境禁止使用 keys 命令、避免一次查询所有的成员，要使用 scan 命令进行分批的，游标式的遍历、通过机制严格控制 Hash、Set、Sorted Set 等结构的数据大小、将排序、并集、交集等操作放在客户端执行，以减少 Redis 服务器运行压力。

#### [#](#_5-使用-slowlog-优化耗时命令) 5.使用 slowlog 优化耗时命令

使用 slowlog 功能找出最耗时的 Redis 命令进行相关的优化，以提升 Redis 的运行速度。

#### [#](#_6-使用-pipeline-批量操作数据) 6.使用 Pipeline 批量操作数据

Pipeline (管道技术) 是客户端提供的一种批处理技术，用于一次处理多个 Redis 命令，从而提高整个交互的性能。

#### [#](#_7-避免大量数据同时失效) 7.避免大量数据同时失效

如果在大型系统中有大量缓存在同一时间同时过期，那么会导致 Redis 循环多次持续扫描删除过期字典，直到过期字典中过期键值被删除的比较稀疏为止，而在整个执行过程会导致 Redis 的读写出现明显的卡顿，卡顿的另一种原因是内存管理器需要频繁回收内存页，因此也会消耗一定的 CPU。

#### [#](#_8-优化客户端使用) 8.优化客户端使用

在客户端的使用上我们除了要尽量使用 Pipeline 的技术外，还需要注意要尽量使用 Redis 连接池，而不是频繁创建销毁 Redis 连接，这样就可以减少网络传输次数和减少了非必要调用指令。

#### [#](#_9-限制-redis-内存大小) 9.限制 Redis 内存大小

在 64 位操作系统中 Redis 的内存大小是没有限制的，这样就会导致在物理内存不足时，使用 swap 空间既交换空间，而当操心系统将 Redis 所用的内存分页移至 swap 空间时，将会阻塞 Redis 进程，导致 Redis 出现延迟，从而影响 Redis 的整体性能。因此我们需要限制 Redis 的内存大小为一个固定的值，来限制 Redis 的内存大小。

#### [#](#_10-使用物理机部署-redis) 10.使用物理机部署 Redis

使用物理机而非虚拟机安装 Redis，在虚拟机中运行 Redis 服务器，因为和物理机共享一个物理网口，并且一台物理机可能有多个虚拟机在运行，因此在内存占用上和网络延迟方面都会有很糟糕的表现。

#### [#](#_11-合理使用持久化的策略) 11.合理使用持久化的策略

对于不重要的数据，我们可以关闭持久化功能，以提升 Redis 的性能。

#### [#](#_12-使用集群模式增加读写吞吐量) 12.使用集群模式增加读写吞吐量

Redis 集群是通过将数据库分散存储到多个节点，以提升 Redis 的整体吞吐量的。









