##                                                                    Redis

### 1.Redis为什么快？

Redis 之所以运行比较快的原因有以下几个：

1. **数据存储在内存中**：Redis 的数据存储在内存中，而内存的读写速度远远快于硬盘。这使得 Redis 能够实现非常快速的读写操作。
2. **单线程处理请求**：Redis 是单线程的，因此可以避免线程切换和锁竞争等问题，提高了 CPU 的利用率和性能。
3. **高效的数据结构**：Redis 提供了多种高效的数据结构，如哈希表、有序集合等，这些数据结构能够快速地进行插入、删除、查找和排序等操作。
4. **异步 I/O**：Redis 使用异步 I/O 技术，可以在等待客户端输入或输出时继续处理其他请求，从而提高了系统的吞吐量。
5. **高效的持久化机制**：Redis 提供了多种持久化机制，如 RDB、AOF 和混合持久化机制，这些机制运行都非常高效，可以在不影响性能的情况下保证数据的安全。

综上所述，Redis 之所以快速，是因为它综合运用了多种优秀的技术和算法，并且针对内存数据库场景做了很多优化。

### 2.Redis可以实现什么功能？

Redis 是一个开源的基于内存的数据结构存储系统，可以实现以下功能：

1. **缓存**：Redis 可以作为缓存系统，将热点数据存储在内存中，提高读写性能和响应速度，减少对后端数据存储的压力。
2. **消息队列**：Redis 的发布订阅功能和 List 数据结构可以实现消息队列的功能，实现异步处理任务、解耦系统组件之间的依赖关系等。
3. **计数器和排行榜**：Redis 的原子操作和 Sorted Set 数据结构可以实现计数器和排行榜的功能，支持快速地增加、减少和排序操作。
4. **分布式锁**：Redis 的 SETNX 命令可以实现分布式锁，避免多个客户端同时修改同一个数据，保证数据的一致性和正确性。
5. **分布式会话管理**：Redis 可以存储会话信息，实现分布式会话管理，支持会话的共享和迁移等功能。

### 3.Redis有哪些数据类型？

Redis 常用的数据类型有 5 种：String 字符串类型、List 列表类型、Hash 哈希表类型、Set 集合类型、Sorted Set 有序集合类型，如下图所示： ![image.png](https://javacn.site/image/1673429563314-89662316-5e2c-4bf0-a07a-d8426b491da2.png) 这 5 种常用类型的用途如下：

1. String（字符串类型）常见使用场景是：存储 Session 信息、存储缓存信息（如详情页的缓存）、存储整数信息，可使用 incr 实现整数+1，和使用 decr 实现整数 -1；
2. List（列表类型）常见使用场景是：实现简单的消息队列、存储某项列表数据；
3. Hash（哈希表类型）常见使用场景是：存储 Session 信息、存储商品的购物车，购物车非常适合用哈希字典表示，使用人员唯一编号作为字典的 key，value 值可以存储商品的 id 和数量等信息、存储详情页信息；
4. Set（集合类型）是一个无序并唯一的键值集合，它的常见使用场景是：关注功能，比如关注我的人和我关注的人，使用集合存储，可以保证人员不会重复；
5. Sorted Set（有序集合类型）相比于 Set 集合类型多了一个排序属性 score（分值），它的常见使用场景是：可以用来存储排名信息、关注列表功能，这样就可以根据关注实现排序展示了。

### 4.有序集合底层是如何实现的？

有序集合类型 (Sorted Set) 相比于集合类型多了一个排序属性 score（分值），对于有序集合 ZSet 来说，每个存储元素相当于有两个值组成的，一个是有序结合的元素值，一个是排序值。有序集合的存储元素值也是不能重复的，但分值是可以重复的，如下图所示： ![img](https://javacn.site/image/1683162474601-2d2e8c2f-7c47-441d-a9ad-f7ed595832e5.png)

**有序集合是由 ziplist (压缩列表) 或 skiplist (跳跃表) 组成的。**

1. 压缩列表 ziplist 本质上就是一个字节数组，是 Redis 为了节约内存而设计的一种线性数据结构，可以包含多个元素，每个元素可以是一个字节数组或一个整数。
2. 跳跃表 skiplist 是一种有序数据结构，它通过在每个节点中维持多个指向其他节点的指针，从而达到快速访问节点的目的。跳跃表支持平均 O(logN)、最坏 O(N) 复杂度的节点查找，还可以通过顺序性操作来批量处理节点。

当数据比较少时，有序集合是压缩列表 ziplist 存储的，反之则为跳跃表 skiplist 存储，使用压缩列表存储必满足以下两个条件：

1. 有序集合保存的元素个数要小于 128 个；
2. 有序集合保存的所有元素成员的长度都必须小于 64 字节。

如果不能满足以上两个条件中的任意一个，有序集合将会使用跳跃表 skiplist 结构进行存储。

### 5.跳跃表底层是如何实现的？

跳跃表的底层是由 C 语言实现的，它的实现源码如下：



```c
typedef struct zskiplistNode {
	// 成员对象
    robj *obj;
    double score; // 分值
    struct zskiplistNode *backward; // 回退指针
    //层
    struct zskiplistLevel {
    	// 前进指针
        struct zskiplistNode *forward;
        // 跨度
        unsigned int span;
    } level[];
} zskiplistNode;
```

- obj：用于存储字符串类型的数据；
- score：用于存储排序的分值；
- backward：后退指针，只能指向当前节点最底层的前一个节点，头节点和第一个节点 backward 指向 NULL，从后向前遍历跳跃表时使用；
- level：柔性数组。每个节点的数组长度不一样，在生成跳跃表节点时，随机生成一个 1-64 的值，值越大出现的概率越低。level 数组的每项包含以下两个元素： 
  - forward：指向本层下一个节点，尾节点的 forward 指向 NULL；
  - span：forward 指向的节点与本节点之间的元素个数，span 值越大，跳过的节点个数越多。

除了跳跃表节点外，还需要一个跳跃表结构来管理节点，Redis 使用 zskiplist 结构体，定义如下：



```c
typedef struct zskiplist {
    struct zskiplistNode *header, *tail;
    unsigned long length;
    int level;
} zskiplist;
```

- header：指向跳跃表头节点。头节点是跳跃表的一个特殊节点，它的 level 数组元素个数为 64。头节点在有序集合中不存储任何 member 和 score 值，ele 值为 NULL, score 值为 0，也不计入跳跃表的总长度。头节点在初始化时，64 个元素的 forward 都指向 NULL,span 值都为 0；
- tail：指向跳跃表尾节点；
- length：跳跃表长度，表示除头节点之外的节点总数；
- level：跳跃表的高度。

它的结构实现如下图所示： ![image.png](https://javacn.site/image/1673579856689-12af8410-614d-47d0-8712-00cf52f4aac9.png)



### 6.Redis如何实现消息队列？

Redis 实现消息队列的常见方法有两种：使用 Redis 中提供的发布订阅（Pub/Sub）功能或 List 数据结构。

具体实现方法如下：

1. 发布订阅（Pub/Sub）：Redis 的发布订阅功能可以实现消息队列的发布和订阅功能。生产者将消息发布到指定的通道（channel）中，消费者可以订阅该通道，接收并处理消息。该模式支持一对多的消息传递，一个消息可以被多个消费者接收，也可以实现分组订阅，将不同的消费者分为不同的组，实现广播或点对点的消息传递。
2. List 数据结构：Redis 的 List 数据结构可以实现消息队列的入队和出队操作。生产者将消息插入到 List 的尾部，消费者从 List 的头部获取消息，实现先进先出（FIFO）的消息处理。可以使用阻塞式的 POP 操作来实现消费者等待新消息到达，也可以使用定时轮询的方式来获取新消息。

#### [#](#发布订阅-vs-list) 发布订阅 VS List

发布订阅和 List 的特点如下：

- 发布订阅：发布订阅是一种一对多的消息传递方式，即一个消息可以被多个消费者同时接收。生产者发布消息到指定的通道，消费者订阅该通道，接收并处理消息。如果消费者在消息发布之前订阅了该通道，则可以接收到该消息；如果在消息发布后才订阅，则无法接收到之前的消息。发布订阅模式适用于广播或点对点的消息传递，但是无法保证消息的顺序。
- List 数据结构：List 数据结构是一种先进先出（FIFO）的消息传递方式，即消息入队列时在队列尾部添加，消息出队列时从队列头部删除。生产者将消息插入到 List 的尾部，消费者从 List 的头部获取消息。可以使用阻塞式的 POP 操作来实现消费者等待新消息到达，也可以使用定时轮询的方式来获取新消息。List 模式适用于需要按顺序处理消息的场景，但是不适用于广播消息传递。

它们的区别如下：

- 发布订阅：优点是可以实现一对多的消息传递，支持分组订阅和模式匹配订阅；缺点是无法保证消息的顺序和可靠性，消费者无法感知到生产者是否已经处理完该消息。
- List 数据结构：优点是可以保证消息的顺序和可靠性，消费者可以在处理完一个消息后再获取下一个消息；缺点是不适用于一对多的消息传递。

#### [#](#小结) 小结

综上所述，发布订阅和 List 数据结构都可以用来实现消息队列，但适用的场景不同，需要根据实际业务需求来选择。如果需要广播或点对点的消息传递，可以选择发布订阅；如果需要按顺序处理消息，可以选择 List 数据结构。

