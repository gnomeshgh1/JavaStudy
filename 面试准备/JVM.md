##                                                                              JVM

### 1.JVM是如何运行的？

JVM（Java Virtual Machine，Java虚拟机）是 Java 程序的运行环境，它负责将 Java 字节码翻译成机器代码并执行。也就是说 Java 代码之所以能够运行，主要是依靠 JVM 来实现的。

JVM 整体的大概执行流程是这样的：

1. 程序在执行之前先要把 Java 代码转换成字节码（class 文件），JVM 首先需要把字节码通过一定的方式**类加载器（ClassLoader）** 把文件加载到内存中**运行时数据区（Runtime Data Area）**；
2. 但字节码文件是 JVM 的一套指令集规范，并不能直接交个底层操作系统去执行，因此需要特定的命令解析器，也就是 JVM 的执行引擎（Execution Engine）会**将字节码翻译成底层系统指令再交由 CPU 去执行；**
3. **在执行的过程中，也需要调用其他语言的接口，如通过调用本地库接口（Native Interface）** 来实现整个程序的运行，如下图所示：

![image.png](https://javacn.site/image/1673751702610-28d9b08a-0b77-4119-aa72-f616f492288c.png)

所以，整体来看， JVM 主要通过分为以下 4 个部分，来执行 Java 程序的，它们分别是：

1. 类加载器（ClassLoader）
2. 运行时数据区（Runtime Data Area）
3. 执行引擎（Execution Engine）
4. 本地库接口（Native Interface）

### 2.什么是类加载器？

类加载器（Class Loader）是 Java 虚拟机（JVM）的重要组成部分，负责将字节码文件加载到内存中并转换为可执行的类。

类加载总共分为以下四种：

1. **启动类加载器（Bootstrap Class Loader）**：它是 JVM 的内部组件，负责加载 Java 核心类库（如java.lang）和其他被系统类加载器所需要的类。启动类加载器是由 JVM 实现提供的，通常使用本地代码来实现。
2. **扩展类加载器（Extension Class Loader）**：它是 sun.misc.Launcher$ExtClassLoader 类的实例，负责加载 Java 的扩展类库（如 java.util、java.net）等。扩展类加载器通常从 java.ext.dirs 系统属性所指定的目录或 JDK 的扩展目录中加载类。
3. **系统类加载器（System Class Loader）**：也称为应用类加载器（Application Class Loader），它是sun.misc.Launcher$AppClassLoader 类的实例，负责加载应用程序的类。系统类加载器通常从 CLASSPATH 环境变量所指定的目录或 JVM 的类路径中加载类。
4. **用户自定义类加载器（User-defined Class Loader）**：这是开发人员根据需要自己实现的类加载器。用户自定义类加载器可以根据特定的加载策略和需求来加载类，例如从特定的网络位置、数据库或其他非传统来源加载类。

如下图所示： ![image.png](https://javacn.site/image/1684135672079-af9234ff-ab54-4f89-b48e-a4fab4348576.png)

### 3.类是如何被加载的？

Java 中类加载总共分为以下 5 个步骤。

#### [#](#_1-加载) 1.加载

加载（Loading）：查找并加载类的二进制数据。这个过程可以通过类的全限定名来完成，也可以通过其他方式完成，比如使用 ClassLoader.loadClass() 方法。

在加载 Loading 阶段，Java 虚拟机需要完成以下 3 件事：

- 通过一个类的全限定名来获取定义此类的二进制字节流；
- 将这个字节流所代表的静态存储结构转化为方法区的运行时数据结构；
- 在内存中生成一个代表这个类的 java.lang.Class 对象，作为方法区这个类的各种数据的访问入口。

#### [#](#_2-验证) 2.验证

验证（Verification）：验证加载的类是否符合 Java 虚拟机规范，比如是否有正确的文件格式、是否有正确的访问权限等。

验证是连接阶段的第一步，这一阶段的目的是确保 Class 文件的字节 流中包含的信息符合《Java虚拟机规范》的全部约束要求，保证这些信 息被当作代码运行后不会危害虚拟机自身的安全。

验证选项：

- 文件格式验证
- 字节码验证
- 符号引用验证...

#### [#](#_3-准备) 3.准备

准备（Preparation）：为类的静态变量分配内存，并设置默认初始值。

准备阶段是正式为类中定义的变量（即静态变量，被static修饰的变量）分配内存并设置类变量初始值的阶段。

比如此时有这样一行代码：

> public static int value = 123;

它是初始化 value 的 int 值为 0，而非 123。

#### [#](#_4-解析) 4.解析

解析（Resolution）：将类中的符号引用转换为直接引用，比如将类中的方法名转换为实际的内存地址。

解析阶段是 Java 虚拟机将常量池内的符号引用替换为直接引用的过程，也就是初始化常量的过程。

#### [#](#_5-初始化) 5.初始化

初始化（Initialization）：执行类的初始化代码，包括静态变量赋值和静态代码块的执行。

#### [#](#小结) 小结

以上 5 个步骤总共分为 3 个大步骤：

1. **加载：** 查找并加载类的二进制数据。

2. 连接：

    将 Java 类的二进制数据合并到 JVM 运行状态之中。 

   1. 验证：验证加载的类是否符合 Java 虚拟机规范。
   2. 准备：为类的静态变量分配内存，并设置默认初始值。
   3. 解析：将类中的符号引用转换为直接引用。

3. **初始化：** 执行类的初始化代码，包括静态变量赋值和静态代码块的执行。

### 4.什么是双亲委派模型？

双亲委派模型是 Java 类加载器的一种工作机制。

它是指当一个类加载器需要加载一个类时，它首先不会自己去尝试加载这个类，而是把这个请求委派给父类加载器去完成，每一个层次的类加载器都是如此，因此所有的加载请求最 终都应该传送到最顶层的启动类加载器中，只有当父加载器反馈自己无 法完成这个加载请求（它的搜索范围中没有找到所需的类）时，子加载器才会尝试自己去完成加载。

自 JDK 1.2 以来，Java 一直保持着三层类加载器、双亲委派的类加载架构器，如下图所示：

![image.png](https://javacn.site/image/1684138730926-305d311d-f3fa-42d3-94fa-0165570b5df9.png)

其中：

- 启动类加载器：加载 JDK 中 lib 目录中 Java 的核心类库，即$JAVA_HOME/lib目录。 扩展类加载器。加载 lib/ext 目录下的类；
- 应用程序类加载器：加载我们写的应用程序；
- 自定义类加载器：根据自己的需求定制类加载器。

双亲委派模型的优点是：

1. **避免重复加载类**：比如 A 类和 B 类都有一个父类 C 类，那么当 A 启动时就会将 C 类加载起来，那么在 B 类进行加载时就不需要在重复加载 C 类了。
2. **更安全**：使用双亲委派模型也可以保证了 Java 的核心 API 不被篡改，如果没有使用双亲委派模型，而是每个类加载器加载自己的话就会出现一些问题，比如我们编写一个称为 java.lang.Object 类的话，那么程序运行的时候，系统就会出现多个不同的 Object 类，而有些 Object 类又是用户自己提供的因此安全性就不能得到保证了。

### 5.说一下JVM内存布局？

通常所说的 JVM 内存布局，一般指的是 JVM 运行时数据区（Runtime Data Area），也就是当字节码被类加载器加载之后的执行区域划分。

《Java虚拟机规范》中将 JVM 运行时数据区域划分为以下 5 部分：

1. **程序计数器（Program Counter Register）**：用于记录当前线程执行的字节码指令地址，是线程私有的，线程切换不会影响程序计数器的值。
2. **Java 虚拟机栈（Java Virtual Machine Stacks）**：用于存储方法执行时的局部变量表、操作数栈、动态链接、方法出口等信息，也是线程私有的。每个方法在执行时都会创建一个栈帧，栈帧包含了方法的局部变量表、操作数栈等信息。
3. **本地方法栈（Native Method Stack**）：与 Java 虚拟机栈类似，用于存储本地方法的信息。
4. **Java 堆（Java Heap）**：用于存储对象实例和数组，是 JVM 中最大的一块内存区域，它是所有线程共享的。堆通常被划分为年轻代和老年代，以支持垃圾回收机制。

- **年轻代（Young Generation**）：用于存放新创建的对象。年轻代又分为 Eden 区和两个 Survivor 区（通常是一个 From 区和一个 To 区），对象首先被分配在 Eden 区，经过垃圾回收后存活的对象会被移到 Survivor 区，经过多次回收后仍然存活的对象会晋升到老年代。
- **老年代（Old Generation）**：用于存放存活时间较长的对象。老年代主要存放长时间存活的对象或从年轻代晋升过来的对象。

1. **方法区（Methed Area**）：用于存储已被虚拟机加载的类信息、常量、静态变量、即时编译器编译后的代码等数据。方法区也是所有线程共享的。

如下图所示![image.png](https://javacn.site/image/1662979290097-558b8691-e861-44f9-930c-04b891ed2830.png)

