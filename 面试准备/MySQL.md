##                                                                         MySQL

### 1.关系型数据库和非关系性数据库有什么区别？

#### 关系型数据库

关系型数据库是一种基于关系模型的数据库，数据以表格的形式组织和存储，并且各个表格之间通过关系建立联系。在关系型数据库中，数据被组织成多个表格，每个表格由多个列和行组成，其中每个列代表表格中的一种属性，每行代表一个记录。

关系型数据库通常采用 SQL（Structured Query Language，结构化查询语言）作为操作和查询语言。SQL 提供了标准化的语法和功能，支持对关系型数据库的数据进行查询、更新、删除和插入等操作。关系型数据库也提供了事务处理和 ACID（原子性、一致性、隔离性和持久性）特性，可以保证数据的一致性和完整性。

常见的关系型数据库包括 Oracle、MySQL、SQL Server、IBM DB2 等。关系型数据库在企业级应用系统中被广泛使用，适用于需要对数据进行高效查询、事务处理和数据一致性保证的场景。

#### [#](#非关系数据库) 非关系数据库

非关系型数据库（NoSQL）是相对于关系型数据库而言的一种数据库分类。与关系型数据库不同的是，非关系型数据库通常不采用传统的表格结构来存储数据，而是采用各种不同的数据模型来存储数据，例如键值对、文档、图形等等。非关系型数据库在处理大量非结构化数据和需要分布式存储、处理和高可扩展性方面具有优势。

非关系型数据库通常采用非结构化的查询语言，例如 MongoDB 使用的查询语言是基于 JavaScript 的。此外，非关系型数据库通常提供分布式的数据存储和处理能力，可以通过横向扩展来扩展数据库的性能和容量。

常见的非关系型数据库包括 MongoDB、Redis、ElasticSearch 等。非关系型数据库在处理大数据、实时数据、云计算和 Web 应用程序等方面具有广泛的应用，尤其适用于需要处理半结构化或非结构化数据的场景。

#### [#](#关系型-vs-非关系型) 关系型 VS 非关系型

关系型数据库和非关系型数据库的区别在于，关系型数据库一般都是有固定的表结构，并且不容易进行扩展；而非关系型数据库的存储机制就有很多了，比如基于文档的，K-V 键值对的，还有基于图的等，对于数据的格式十分灵活没有固定的表结构，方便扩展。因此如果业务的数据结构并不是固定的或者经常变动比较大的，那么非关系型数据库是个好的选择。

总结来说，关系型和非关系数据库的区别体现在以下几方面：

1. 数据存储：关系型数据库采用表格形式存储数据，每个表格包含多个行和列，每一行代表一条记录，每一列代表一种属性。关系型数据库中的表格之间通过外键建立关系；而非关系型数据库则不使用表格形式存储数据，通常采用键值对的方式存储数据，也可以使用文档型、列型、图形等方式存储。
2. 查询方式：关系型数据库使用 SQL 查询语言进行查询，可以进行复杂的关系查询，支持数据的联接、分组、排序等操作；非关系型数据库通常使用特定的 API 进行查询，查询方式通常比较简单，主要是根据键值对进行查询和过滤。
3. 事务支持：关系型数据库支持事务处理和 ACID（原子性、一致性、隔离性和持久性）特性，可以保证数据的完整性和一致性：非关系型数据库通常不支持事务处理和 ACID 特性。

### 2.什么是数据库三范式？

数据库三范式是指关系型数据库设计中的三种规范化设计原则，旨在减少数据冗余、提高数据一致性和可维护性。

#### [#](#_1-第一范式) 1.第一范式

第一范式规定表中的每个列都应该是不可分割的最小单元。比如以下表中的 address 字段就不是不可分割的最小单元，如下图所示： ![image.png](https://javacn.site/image/1648295831985-ddbb0366-f6d5-4454-8879-653a02358898.png) 

 address 还可以拆分为国家和城市，如下图所示：![image.png](https://javacn.site/image/1648295837649-17ffae73-4342-4331-ada5-7041d33e9a01.png) 

这样改造之后，上面的表就满足第一范式了。

#### [#](#_2-第二范式) 2.第二范式

第二范式是在满足第一范式的基础上，规定表中的非主键列不存在对主键的部分依赖，也就是说每张表只描述一件事情，比如以下订单表就不满足第二范式，它可以拆分为两张独立的表：订单表和商品表。

#### [#](#_2-1-不满足第二范式的订单表) 2.1 不满足第二范式的订单表

![image.png](https://javacn.site/image/1648298009402-1c42c52c-3a46-4760-b1bf-1c99e57ff7b0.png)

> PS：上面的表可拆分为两张独立的表：订单表和商品表。

#### [#](#_2-2-满足第二范式的表) 2.2 满足第二范式的表

订单表： ![image.png](https://javacn.site/image/1648297941960-bd9764a5-f8c4-471d-96c7-42e9b81ab905.png) 商品表： ![image.png](https://javacn.site/image/1648298020290-a8874a2a-ea00-4548-86fe-4960fe96411c.png)

#### [#](#_3-第三范式) 3.第三范式

第三范式是在满足第一范式和第二范式的基础上，规定表中的列不存在对非主键列的传递依赖。比如以下的订单表中的顾客名称就不符合第三范式，因为它存在了对非主键顾客编号的依赖，如下图所示：![image.png](https://javacn.site/image/1648296977841-40b4cc30-2bec-4b61-b8bc-f330b443b003.png) 修改之后（符合第三范式）的表结构如下： ![image.png](https://javacn.site/image/1648297045480-9b719706-a411-47f6-bb19-c34cc3f24efe.png)

#### [#](#小结) 小结

第一范式规定表中的每个列都应该是不可分割的最小单元。第二范式是在满足第一范式的基础上，规定表中的非主键列不存在对主键的部分依赖。第三范式是在满足第一范式和第二范式的基础上，规定表中的列不存在对非主键列的传递依赖。使用数据库三范式的优势是：表的结构更简单、优雅，表的逻辑和条理性更强，并且使用三范式可以很大程度的减少表中的冗余数据，很好的节省了数据库的存储资源。

### 3.MySQL有哪些存储引擎？

MySQL 有很多数据引擎，也叫存储引擎，所谓的存储引擎是指用于存储、检索、更新和删除数据的服务。

在 MySQL 中可以使用“show engines”来查询数据库的所有存储引擎，如下图所示：![image.png](https://javacn.site/image/1651279782275-504eeaf8-b7bb-4c2d-b0e6-c52d40ae59dd.png)在上述列表中，我们最常用的存储引擎有以下 3 种：

1. InnoDB
2. MyISAM
3. MEMORY

下面我们分别来看。

#### [#](#_1-innodb) 1.InnoDB

InnoDB 是 MySQL 5.5 之后默认的存储引擎，它支持事务、支持外键、支持崩溃修复和自增列。如果对业务的完整性要求较高，比如张三给李四转账，需要减张三的钱，同时给李四加钱，这时候只能全部执行成功或全部执行失败，此时可以通过 InnoDB 来控制事务的提交和回滚，从而保证业务的完整性。

#### [#](#优缺点分析) 优缺点分析

InnoDB 的优势是支持事务、支持外键、支持崩溃修复和自增列；它的缺点是读写效率较差、占用的数据空间较大。

#### [#](#_2-myisam) 2.MyISAM

MyISAM 是 MySQL 5.5 之前默认的数据库引擎，读取效率较高，占用数据空间较少，但不支持事务、不支持行级锁、不支持外键等特性。因为不支持行级锁，因此在添加和修改操作时，会执行锁表操作，所以它的写入效率较低。

#### [#](#优缺点分析-1) 优缺点分析

MyISAM 引擎保存了单独的索引文件 .myi，且它的索引是直接定位到 OFFSET 的，而 InnoDB 没有单独的物理索引存储文件，且 InnoDB 索引寻址是先定位到块数据，再定位到行数据，所以 MyISAM 的查询效率是比 InnoDB 的查询效率要高。但它不支持事务、不支持外键，所以它的适用场景是读多写少，且对完整性要求不高的业务场景。

#### [#](#_3-memory) 3.MEMORY

内存型数据库引擎，所有的数据都存储在内存中，因此它的读写效率很高，但 MySQL 服务重启之后数据会丢失。它同样不支持事务、不支持外键。MEMORY 支持 Hash 索引或 B 树索引，其中 Hash 索引是基于 key 查询的，因此查询效率特别高，但如果是基于范围查询的效率就比较低了。而前面两种存储引擎是基于 B+ 树的数据结构实现了。

#### [#](#优缺点分析-2) 优缺点分析

MEMORY 读写性能很高，但 MySQL 服务重启之后数据会丢失，它不支持事务和外键。适用场景是读写效率要求高，但对数据丢失不敏感的业务场景。

#### [#](#_4-查看和设置存储引擎) 4.查看和设置存储引擎

#### [#](#_4-1-查看存储引擎) 4.1 查看存储引擎

存储引擎的设置粒度是表级别的，也就是每张表可以设置不同的存储引擎，我们可以使用以下命令来查询某张表的存储引擎：



```sql
show create table t;
```

如下图所示： ![image.png](https://javacn.site/image/1651281305965-96055bb3-c37b-4b34-994a-ac6ad182baf8.png)

#### [#](#_4-2-设置存储引擎) 4.2 设置存储引擎

在创建一张表的时候设置存储引擎： ![image.png](https://javacn.site/image/1651281618448-2940b146-2e82-40e6-abe2-55394d0ad379.png) 修改一张已经存在表的存储引擎：![image.png](https://javacn.site/image/1651281589885-672a6374-3682-499d-8644-b36bf68a9f15.png)

#### [#](#小结) 小结

MySQL 中最常见的存储引擎有：InnoDB、MyISAM 和 MEMORY，其中 InnoDB 是 MySQL 5.5 之后默认的存储引擎，它支持事务、支持外键、支持崩溃修复和自增列，它的特点是稳定（能保证业务的完整性），但数据的读写效率一般；而 MyISAM 的查询效率较高，但不支持事务和外键；MEMORY 的读写效率最高，但因为数据都保存在内存中的，所以 MySQL 服务重启之后数据就会丢失，因此它只适用于数据丢失不敏感的业务场景。

### 4.MyISAM和InnoDB有什么区别？

MyISAM 和 InnoDB 都是 MySQL 中最常用的两种存储引擎，在 MySQL 的官方文档中，可以看出二者的区别，官方说明链接如下：

1. InnoDB 引擎说明：[https://dev.mysql.com/doc/refman/8.0/en/innodb-introduction.htmlopen in new window](https://dev.mysql.com/doc/refman/8.0/en/innodb-introduction.html)
2. MyISAM 引擎说明：[https://dev.mysql.com/doc/refman/8.0/en/myisam-storage-engine.htmlopen in new window](https://dev.mysql.com/doc/refman/8.0/en/myisam-storage-engine.html)

考虑到便捷性和易读性我这里整合了一幅图，并将官方文档翻译成了中文，二者的区别如下：![image.png](https://javacn.site/image/1682157182555-e307d4ca-42e0-43a3-abd2-0332257ae0fc.png)从上面的对比图中我们可以看出，它们的区别主要体现在以下 7 点：

1. 事务支持不同：MyISAM 是非事务型存储引擎，它不支持事务操作；而 InnoDB 是事务型存储引擎，所以它是支持事务操作的，它可以保证数据的完整性和一致性。
2. 聚集索引的支持不同：MyISAM 不支持聚集索引，而 InnoDB 支持聚集索引。
3. 数据缓存支持不同：MyISAM 不支持数据缓存，而 InnoDB 支持数据缓存。
4. 外键支持不同：MyISAM 不支持外键，而 InnoDB 支持外键。
5. 锁粒度不同：InnoDB 支持行级锁定，可以对数据表的某行进行锁定，而不会锁定整个表，这样可以提高并发读写的能力；而 MyISAM 只支持表级锁定，只能对整个表进行锁定，这样容易造成大量的读写冲突和性能瓶颈。
6. 存储限制不同：MyISAM 支持 256TB 的数据存储，而 InnoDB 只支持 64TB 的数据存储。
7. MVCC 支持不同：MVCC （多版本并发控制）是一种数据库管理系统中的并发控制方法，它允许多个事务同时读取数据库中的同一数据，而不会相互干扰。MVCC通过为每个事务创建一个独立的“视图”来实现这一点，该视图显示了数据库在该事务开始时的状态。当事务读取数据时，它只能看到该视图中的数据，而不是实际的数据库状态。这意味着即使其他事务正在修改相同的数据，该事务也不会受到影响，因为它只能看到它开始时的数据状态。MyISAM 是不支持 MVCC 的，而 InnoDB 支持。

### 5.索引类型有哪些？

索引是一种数据结构，使用它可以快速的查询和检索数据。它可以看做是一本书的目录介绍，使用它可以快速地定位到需要查询的内容。 ![image.png](https://javacn.site/image/1682234465023-f76f7825-6db1-4fe4-a7d0-fe9c0606dcc7.png)

#### [#](#索引分类) 索引分类

索引一般可以分为以下几类：

1. 主键索引：主键索引是一种特殊的索引类型，它是用于唯一标识每一行数据的索引，每个表只能有一个主键索引。
2. 唯一索引：唯一索引是用来保证列的唯一性的索引，一个表可以有多个唯一索引。
3. 普通索引：普通索引也叫非唯一索引，它是最常见的一种索引类型，可以加速查询和排序操作。
4. 全文索引：全文索引是一种用于全文搜索的索引类型，能够对文本数据进行快速的模糊搜索和关键字搜索。
5. 复合索引：复合索引也叫多列索引或联合索引，它是包含多个列的索引类型，能够加速多列查询和排序操作。
6. 哈希索引：哈希索引是基于哈希表实现的索引类型，能够对等值查询进行高效的处理，但不支持范围查询和排序，MySQL 中 Memory 引擎中支持哈希索引。

#### [#](#优缺点分析) 优缺点分析

索引的主要优点如下：

1. 提高查询效率：索引可以加速数据的检索速度，对于大量数据的表而言，使用索引可以大幅提高查询效率。
2. 避免全表扫描：当没有索引时，数据库会进行全表扫描，而索引可以帮助避免全表扫描，加速查询。
3. 增强数据的唯一性和完整性：可以通过在列上创建唯一索引和主键索引来确保表中的数据唯一性和完整性。

索引的缺点如下：

1. 占用额外存储空间：每个索引都会占用额外的存储空间，因此在设计索引时需要权衡存储空间和查询效率之间的平衡。
2. 降低写操作效率：索引的维护需要额外的写操作，因此在大量写操作的情况下可能会降低写操作的效率。
3. 可能出现索引失效：索引并不是万能的，有些情况下使用索引可能会导致查询效率降低甚至出现索引失效的情况。例如，当对于一个非常小的表或者一个稠密的索引列进行查询时，使用索引可能并不会提高查询效率。
4. 索引需要维护：随着表数据的不断变化，索引也需要不断维护以保持其效率。因此，在使用索引时需要注意索引的维护成本。

#### [#](#应用场景) 应用场景

适合创建索引的场景有以下几个：

1. 频繁用于条件查询的列：如果一个列经常用于 WHERE、JOIN、ORDER BY 或 GROUP BY 子句中，那么可以考虑在该列上创建索引。
2. 唯一性约束：对于需要保证唯一性的列，应该在该列上创建唯一索引或主键索引。
3. 经常用于排序的列：对于需要经常进行排序的列，如 ORDER BY 子句中的列，应该在该列上创建索引。
4. 经常用于聚合函数的列：对于经常用于聚合函数（如 COUNT、AVG、SUM、MIN、MAX）的列，应该在该列上创建索引，可以加速聚合查询。

虽然索引可以提高查询效率，但有些情况下并不适合使用索引，比如以下这些：

1. 对于小表：如果表的数据量比较小，那么建立索引并不能带来很大的性能提升，反而会增加查询时间和占用存储空间。
2. 对于多写少读的表：索引会增加写操作的时间，并占用更多的存储空间，因此对于频繁进行 INSERT、UPDATE 或 DELETE 操作的表，不宜过多地建立索引。

总之，创建索引需要根据具体的情况进行权衡和取舍，只有在真正需要提高查询效率时才应该创建索引，否则会浪费存储空间和增加写操作的时间。

### 6.什么是最左匹配原则？

最左匹配原则是指在使用复合索引（也叫联合索引），即由多个列组成的索引时，只有从索引的最左边的列开始进行查询，才能利用到该复合索引。

例如，如果有一个联合索引为 (col1, col2, col3)，那么只有按照以下顺序进行查询才能利用该索引：

- col1
- col1, col2
- col1, col2, col3

而如果查询是这样的：

- col2
- col2, col3

则不能使用该复合索引。

#### [#](#为什么必须要最左匹配) 为什么必须要最左匹配？

例如，我们以 (年龄,姓名,住址) 为联合索引，如下图所示： ![image.png](https://javacn.site/image/1682242267779-d5fbc974-f9ec-47f2-acb4-6e72d9ca0d49.png)此时只有我们使用了最左匹配原则：(年龄)或(年龄,姓名)或(年龄,姓名,住址) 才能顺利的找到对应的数据，否则将无法使用上图中的联合索引进行高效的查询了。

### 7.索引底层是怎么实现的？

MySQL 中默认的存储引擎 InnoDB 的索引是使用 B+ 树实现的。B+ 树是一种多路搜索树，它的叶子节点存储了所有的数据行信息，叶子节点之间使用指针连接，方便范围查询和排序等操作，非叶子节点存储的是索引字段的值，这样就可以通过非叶子节点的索引值快速定位到叶子节点的数据了，索引的实现如下图所示： ![image.png](https://javacn.site/image/1682243389907-e5682d90-12de-433f-99f4-4af37ff9cbca.png)

#### [#](#b-树优点分析) B+ 树优点分析

#### [#](#_1-查询效率) 1.查询效率

B+ 树的非叶子节点不存放实际的记录数据，仅存放索引，因此数据量相同的情况下，相比即存索引又存记录的 B 树，B+ 树的非叶子节点可以存放更多的索引，因此 B+ 树可以比 B 树更「矮胖」，查询底层节点的磁盘 I/O 次数会更少。

#### [#](#_2-插入和删除效率) 2.插入和删除效率

B+ 树有大量的冗余节点，这样使得删除一个节点的时候，可以直接从叶子节点中删除，甚至可以不动非叶子节点，这样删除非常快， 比如下面这个动图是删除 B+ 树 0004 节点的过程，因为非叶子节点有 0004 的冗余节点，所以在删除的时候，树形结构变化很小：

![img](https://javacn.site/image/1682244209305-db3b05f0-890a-46b4-9a19-acbacd50f9cf.gif)

B 树则不同，B 树没有冗余节点，删除节点的时候非常复杂，比如删除根节点中的数据，可能涉及复杂的树的变形，比如下面这个动图是删除 B 树根节点的过程：

![img](https://javacn.site/image/1682244209314-a0806a8c-365e-4dea-ba39-56b9c849c256.gif)

B+ 树的插入也是一样，有冗余节点，插入可能存在节点的分裂（如果节点饱和），但是最多只涉及树的一条路径。而且 B+ 树会自动平衡，不需要像更多复杂的算法，类似红黑树的旋转操作等。因此，B+ 树的插入和删除效率更高。

#### [#](#_3-范围查询) 3.范围查询

因为 B+ 树所有叶子节点间还有一个链表进行连接，这种设计对范围查找非常有帮助，比如说我们想知道 12 月 1 日和 12 月 12 日之间的订单，这个时候可以先查找到 12 月 1 日所在的叶子节点，然后利用链表向右遍历，直到找到 12 月12 日的节点，这样就不需要从根节点查询了，进一步节省查询需要的时间。

而 B 树没有将所有叶子节点用链表串联起来的结构，因此只能通过树的遍历来完成范围查询，这会涉及多个节点的磁盘 I/O 操作，范围查询效率不如 B+ 树。

因此，存在大量范围检索的场景，适合使用 B+树。

### 8.聚簇索引与非聚簇索引的区别？

聚簇索引和非聚簇索引都是用于加速数据库查询的索引类型，它们的主要区别在于数据的存储和查询上。

#### [#](#概念说明) 概念说明

聚簇索引（Clustered Index）也被称为聚集索引，在 InnoDB 存储引擎中，每个表只能有一个聚集索引，其余的索引都是非聚集索引（也称为二级索引）。

聚集索引是按照数据在磁盘上的物理顺序来组织数据的，其叶子节点保存着完整的数据行信息。InnoDB 中，如果表定义了主键，则主键索引是聚集索引；如果表没有定义主键，则第一个唯一非空索引是聚集索引；如果都没有，则 InnoDB 会隐式创建一个隐藏的聚集索引。

例如，我们创建一张 student 表，它的构建 SQL 如下：



```sql
drop table if exists student;
create table student(
    id int primary key, 
    name varchar(16),
    class_id int not null, 
    index (class_id)
)engine=InnoDB;
-- 添加测试数据
insert into student(id,name,class_id) values(100,'张三',1),
    (200,'李四',2),(300,'王五',3);
```

以上 student 表中有一个聚簇索引（也就是主键索引）id，和一个非聚簇索引 class_id。 聚簇索引 id 对应存储结构如下图所示： !![image.png](https://javacn.site/image/1647780500089-e5d32fb1-a84b-43ca-a182-a82406c674fb.png) 非聚集索引也叫二级索引，其叶子节点保存着索引字段和指向对应数据行的指针（相当于主键 ID)，通过这个指针可以找到对应的数据行。在查询中，如果使用的是非聚集索引，则需要先根据索引查找到对应的行指针，再通过行指针查找数据行，这个过程叫做回表查询，因此他的查询速度相对于聚集索引要慢一些。

以上面 student 表为例，在 student 中非聚簇索引 class_id 对应存储结构如下图所示： ![image.png](https://javacn.site/image/1647780485345-7dde96c5-e5d4-42d6-bef5-af9939cb791e.png)

 从上图我们可以看出，**在非聚簇索引的叶子节点上存储的并不是真正的行数据，而是主键 ID，所以当我们使用非聚簇索引进行查询时，首先会得到一个主键 ID，然后再使用主键 ID 去聚簇索引上找到真正的行数据，所以查询速度要慢一些。**

#### [#](#聚簇索引-vs-非聚簇索引) 聚簇索引 VS 非聚簇索引

聚簇索引和非聚簇索引的区别主要有以下几点：

1. 存储数据不同：聚簇索引将数据行存储在与索引相同的 B+ 树结构中，而非聚簇索引是将索引和主键 ID 存储在 B+ 树结构中；
2. 数量限制不同：一张表只能有一个聚簇索引，但可以有多个非聚簇索引；
3. 索引更新不同：由于聚簇索引中的数据行与索引行是一一对应的，因此对于聚簇索引的任何更新都需要重新排列数据行的物理顺序。这可能会导致性能问题，特别是在高并发环境中，而非聚簇索引的更新不需要重新排列数据行的物理顺序，因为索引和数据行是分开存储的；
4. 索引大小不同：由于聚簇索引中的数据行与索引行是一一对应的，因此聚簇索引的大小通常比非聚簇索引大，而非聚簇索引通常比较小，因为它们只存储索引不存储数据行；
5. 范围查询不同：聚簇索引中的数据行与索引行是一一对应的，因此聚簇索引通常比非聚簇索引更适合范围查询，而非聚簇索引需要进行两次查找：首先查找索引，然后查找数据行，这可能会导致性能问题，特别是在大型表上进行范围查询时。

### 9.什么时候会导致索引失效？

索引失效是指在 SQL 查询中，索引没有被使用到，这种情况下，MySQL 会进行全表扫描，这种情况下，查询效率会很低，甚至会导致服务器负载过高，甚至宕机。

导致索引失效的场景有以下这些：

1. 未遵循最左匹配原则
2. 使用列运算
3. 使用函数方法
4. 类型转换
5. 使用 is not null
6. 错误的模糊匹配

接下来，我们一个一个来看。

#### [#](#准备工作) 准备工作

为了验证 MySQL 中哪些情况下会导致索引失效，我们可以借助 explain 执行计划来分析索引失效的具体场景。 explain 使用如下，只需要在查询的 SQL 前面添加上 explain 关键字即可，如下图所示： ![image.png](/image/1647607336631-1ed0d39e-8d69-474e-a736-7e96b2c75090.png)**而以上查询结果的列中，我们最主要观察 key 这一列，key 这一列表示实际使用的索引，如果为 NULL 则表示未使用索引，反之则使用了索引。**

以上所有结果列说明如下：

- id — 选择标识符，id 越大优先级越高，越先被执行；
- select_type — 表示查询的类型；
- table — 输出结果集的表；
- partitions — 匹配的分区；
- type — 表示表的连接类型；
- possible_keys — 表示查询时，可能使用的索引；
- **key — 表示实际使用的索引；**
- key_len — 索引字段的长度；
- ref— 列与索引的比较；
- rows — 大概估算的行数；
- filtered — 按表条件过滤的行百分比；
- Extra — 执行情况的描述和说明。

其中最重要的就是 type 字段，type 值类型如下：

- all — 扫描全表数据；
- index — 遍历索引；
- range — 索引范围查找；
- index_subquery — 在子查询中使用 ref；
- unique_subquery — 在子查询中使用 eq_ref；
- ref_or_null — 对 null 进行索引的优化的 ref；
- fulltext — 使用全文索引；
- ref — 使用非唯一索引查找数据；
- eq_ref — 在 join 查询中使用主键或唯一索引关联；
- const — 将一个主键放置到 where 后面作为条件查询， MySQL 优化器就能把这次查询优化转化为一个常量，如何转化以及何时转化，这个取决于优化器，这个比 eq_ref 效率高一点。

#### [#](#创建测试表和数据) 创建测试表和数据

为了演示和测试那种情况下会导致索引失效，我们先创建一个测试表和相应的数据：



```sql
-- 创建表
drop table if exists student;
create table student(
    id int primary key auto_increment comment '主键',
    sn varchar(32) comment '学号',
    name varchar(250) comment '姓名',
    age int comment '年龄',
    sex bit comment '性别',
    address varchar(250) comment '家庭地址',
    key idx_address (address),
    key idx_sn_name_age (sn,name,age)
)ENGINE=InnoDB DEFAULT CHARSET=utf8;
-- 添加测试数据
insert into student(id,sn,name,age,sex,address) 
    values(1,'cn001','张三',18,1,'高老庄'),
    (2,'cn002','李四',20,0,'花果山'),
    (3,'cn003','王五',50,1,'水帘洞');
```

当前表中总共有 3 个索引，如下图所示： ![image.png](https://javacn.site/image/1646577258020-36b2d92b-c467-4b09-809c-4b760aafbb49.png)

> PS：本文以下内容基于 MySQL 5.7 InnoDB 数据引擎下。

#### [#](#未遵循最左匹配原则) 未遵循最左匹配原则

**最左匹配原则指的是，以最左边的为起点字段查询可以使用联合索引，否则将不能使用联合索引。** 我们本文的联合索引的字段顺序是 sn + name + age，我们假设它们的顺序是 A + B + C，以下联合索引的使用情况如下： ![image.png](https://javacn.site/image/1646577651625-43939112-7e0c-4f3a-87fe-ab5ca085525d.png) 从上述结果可以看出，如果是以最左边开始匹配的字段都可以使用上联合索引，比如：

- A+B+C
- A+B
- A+C

> 其中：A 等于字段 sn，B 等于字段 name，C 等于字段 age。

而 B+C 却不能使用到联合索引，这就是最左匹配原则。

#### [#](#列运算) 列运算

如果索引列使用了运算，那么索引也会失效，如下图所示： !![image.png](https://javacn.site/image/1646578869261-fe3b22db-9808-4c20-a67b-c03c58e8db80.png)

#### [#](#函数方法) 函数方法

查询列如果使用任意 MySQL 提供的函数就会导致索引失效，比如以下列使用了 ifnull 函数之后的执行计划如下： !![image.png](https://javacn.site/image/1646579076361-b9abb3cd-f631-4da0-8888-c66d7c583e45.png)

#### [#](#类型转换) 类型转换

如果索引列存在类型转换，那么也不会走索引，比如 address 为字符串类型，而查询的时候设置了 int 类型的值就会导致索引失效，如下图所示： ![image.png](https://javacn.site/image/1646579296829-4d3ab5dc-bd5a-4cff-b489-3c57dc49184a.png)

#### [#](#使用-is-not-null) 使用 is not null

当在查询中使用了 is not null 也会导致索引失效，而 is null 则会正常触发索引的，如下图所示： ![image.png](https://javacn.site/image/1646579682841-ed7325a2-60c7-49b3-a8b7-197e11b28eac.png)

#### [#](#错误的模糊查询) 错误的模糊查询

模糊查询 like 的常见用法有 3 种：

1. 模糊匹配后面任意字符：like '张%'
2. 模糊匹配前面任意字符：like '%张'
3. 模糊匹配前后任意字符：like '%张%'

而这 3 种模糊查询中只有第 1 种查询方式可以使用到索引，具体执行结果如下： ![image.png](https://javacn.site/image/1646578581427-b0a7ae4a-9d77-4b50-a49b-a55307a60359.png)

### 10.事务有哪些特征？

MySQL 事务具有以下四大特性：

1. 原子性（Atomicity）：事务中的所有操作要么全部执行成功，要么全部失败回滚，不能只执行其中一部分操作。
2. 一致性（Consistency）：事务执行前后，数据库的完整性约束没有被破坏，数据总是从一个一致性状态转移到另一个一致性状态。例如，如果一个事务要求将某个账户的金额从 A 转移到 B，那么无论事务是否成功，最终账户 A 和账户 B 的总金额应该保持不变。
3. 隔离性（Isolation）：事务之间是相互隔离的，每个事务对其他事务的操作是透明的，一个事务的中间结果对其他事务是不可见的。隔离性可以防止并发执行的事务之间产生脏读、不可重复读和幻读等问题。
4. 持久性（Durability）：事务完成后，对数据库的修改将永久保存在数据库中，即使系统故障也不会丢失。

事务四大特性是为了保证数据库的数据一致性和可靠性的，使得数据库在并发访问和故障恢复等复杂环境下，仍能保持数据的完整性。

这些特性对于许多应用场景，尤其是需要处理关键业务数据的应用，是非常重要的。例如在转账业务中，它分为两个关键性操作，首先是先扣除一个账户的钱，其次再给另一个账号增加钱。但是如果没有事务的保证，那么有可能第一次操作钱被扣了，但另一个账户钱没增加，那么这笔钱就凭空“消失”了。

#### [#](#什么是一致性) 什么是一致性？

比如你正在玩一款多人在线游戏，这个游戏需要在不同的玩家之间进行数据传输，比如玩家位置、游戏状态等。为了保证游戏的公平性和可玩性，游戏服务器需要确保所有玩家看到的游戏状态都是一致的，即任何一个玩家对游戏状态的修改，都必须在其他玩家看到之前同步到游戏服务器和其他玩家的终端。 在这个例子中，如果游戏服务器在处理数据时出现了错误，导致某个玩家看到的游戏状态与其他玩家不一致，就会破坏游戏的公平性和可玩性。因此，在多人在线游戏中，一致性是非常重要的。在数据库系统中，也是类似的，保证数据的一致性是数据库系统的一个基本目标。

#### [#](#如何保证事务的四大特性) 如何保证事务的四大特性？

以默认的引擎 InnoDB 为例，它保证四大特性的手段分别是：

1. 原子性是通过 undo log（回滚日志） 来保证的，InnoDB 使用日志（undo log）来记录事务的操作，包括事务开始、修改数据和事务提交等。如果事务执行失败或回滚，InnoDB 可以使用日志来撤销已经执行的操作，确保事务的原子性。
2. 持久性是通过 redo log （重做日志）来保证的，在事务提交之前，InnoDB 会将事务的修改操作先写入事务日志（redo log），然后再将数据写入磁盘。即使在系统崩溃或断电的情况下，InnoDB 可以通过重放事务日志来恢复数据，确保事务的持久性。
3. 隔离性是通过 MVCC（多版本并发控制） 和锁机制来保证的。
4. 一致性是通过各种约束，如主键、外键、唯一性约束等，加上事务的持久性、原子性和隔离性来保证的。

11.事务隔离级别有哪些？

在 MySQL 中，事务的隔离级别指的是多个并发事务之间的隔离程度，它有四个级别：读未提交（Read Uncommitted）、读已提交（Read Committed）、可重复读（Repeatable Read）和串行化（Serializable）。

它们的具体区别如下：

1. 读未提交（Read Uncommitted）
   1. 特点：最低的隔离级别，事务中的修改，即使未提交，也可以被其他事务读取到。
   2. 优点：并发性能最好，读取到的数据最新。
   3. 缺点：**存在脏读（Dirty Read）问题**，即读取到未提交的数据，可能导致数据不一致性。
2. 读已提交（Read Committed）
   1. 特点：保证事务读取到的数据都是已经提交的，其他事务提交的数据对该事务可见。
   2. 优点：避免了脏读的问题。
   3. 缺点：**存在不可重复读（Non-Repeatable Read）问题**，即同一个事务中，不同时间读取到的数据可能不一样。
3. 可重复读（Repeatable Read）
   1. 特点：保证同一个事务中，多次读取同一条记录时，读取到的数据都是一致的，MySQL 默认的事务隔离级别。
   2. 优点：避免了不可重复读的问题。
   3. 缺点：**存在幻读（Phantom Read）问题**，即在一个事务中，两次查询同一个范围的记录，但第二次查询却发现了新的记录。
4. 串行化（Serializable）
   1. 特点：最高的隔离级别，将所有的事务串行执行，保证了数据的完全隔离。
   2. 优点：避免了幻读的问题。
   3. 缺点：**并发性能最差**，可能导致大量的锁等待和死锁。

通常情况下，可重复读是一个比较好的选择，能够较好地平衡数据一致性和并发性能。

#### [#](#小结) 小结

MySQL 中的事务隔离级别，主要有读未提交、读已提交、可重复度和串行化。这些隔离级别与问题的对应关系如下：

| **事务隔离级别**             | **脏读** | **不可重复读** | **幻读** |
| ---------------------------- | -------- | -------------- | -------- |
| 读未提交（READ UNCOMMITTED） | √        | √              | √        |
| 读已提交（READ COMMITTED）   | ×        | √              | √        |
| 可重复读（REPEATABLE READ）  | ×        | ×              | √        |
| 串行化（SERIALIZABLE）       | ×        | ×              | ×        |











