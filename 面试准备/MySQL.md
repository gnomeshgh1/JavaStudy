##                                                                         MySQL

### 1.关系型数据库和非关系性数据库有什么区别？

#### 关系型数据库

关系型数据库是一种基于关系模型的数据库，数据以表格的形式组织和存储，并且各个表格之间通过关系建立联系。在关系型数据库中，数据被组织成多个表格，每个表格由多个列和行组成，其中每个列代表表格中的一种属性，每行代表一个记录。

关系型数据库通常采用 SQL（Structured Query Language，结构化查询语言）作为操作和查询语言。SQL 提供了标准化的语法和功能，支持对关系型数据库的数据进行查询、更新、删除和插入等操作。关系型数据库也提供了事务处理和 ACID（原子性、一致性、隔离性和持久性）特性，可以保证数据的一致性和完整性。

常见的关系型数据库包括 Oracle、MySQL、SQL Server、IBM DB2 等。关系型数据库在企业级应用系统中被广泛使用，适用于需要对数据进行高效查询、事务处理和数据一致性保证的场景。

#### [#](#非关系数据库) 非关系数据库

非关系型数据库（NoSQL）是相对于关系型数据库而言的一种数据库分类。与关系型数据库不同的是，非关系型数据库通常不采用传统的表格结构来存储数据，而是采用各种不同的数据模型来存储数据，例如键值对、文档、图形等等。非关系型数据库在处理大量非结构化数据和需要分布式存储、处理和高可扩展性方面具有优势。

非关系型数据库通常采用非结构化的查询语言，例如 MongoDB 使用的查询语言是基于 JavaScript 的。此外，非关系型数据库通常提供分布式的数据存储和处理能力，可以通过横向扩展来扩展数据库的性能和容量。

常见的非关系型数据库包括 MongoDB、Redis、ElasticSearch 等。非关系型数据库在处理大数据、实时数据、云计算和 Web 应用程序等方面具有广泛的应用，尤其适用于需要处理半结构化或非结构化数据的场景。

#### [#](#关系型-vs-非关系型) 关系型 VS 非关系型

关系型数据库和非关系型数据库的区别在于，关系型数据库一般都是有固定的表结构，并且不容易进行扩展；而非关系型数据库的存储机制就有很多了，比如基于文档的，K-V 键值对的，还有基于图的等，对于数据的格式十分灵活没有固定的表结构，方便扩展。因此如果业务的数据结构并不是固定的或者经常变动比较大的，那么非关系型数据库是个好的选择。

总结来说，关系型和非关系数据库的区别体现在以下几方面：

1. 数据存储：关系型数据库采用表格形式存储数据，每个表格包含多个行和列，每一行代表一条记录，每一列代表一种属性。关系型数据库中的表格之间通过外键建立关系；而非关系型数据库则不使用表格形式存储数据，通常采用键值对的方式存储数据，也可以使用文档型、列型、图形等方式存储。
2. 查询方式：关系型数据库使用 SQL 查询语言进行查询，可以进行复杂的关系查询，支持数据的联接、分组、排序等操作；非关系型数据库通常使用特定的 API 进行查询，查询方式通常比较简单，主要是根据键值对进行查询和过滤。
3. 事务支持：关系型数据库支持事务处理和 ACID（原子性、一致性、隔离性和持久性）特性，可以保证数据的完整性和一致性：非关系型数据库通常不支持事务处理和 ACID 特性。

### 2.什么是数据库三范式？

数据库三范式是指关系型数据库设计中的三种规范化设计原则，旨在减少数据冗余、提高数据一致性和可维护性。

#### [#](#_1-第一范式) 1.第一范式

第一范式规定表中的每个列都应该是不可分割的最小单元。比如以下表中的 address 字段就不是不可分割的最小单元，如下图所示： ![image.png](https://javacn.site/image/1648295831985-ddbb0366-f6d5-4454-8879-653a02358898.png) 

 address 还可以拆分为国家和城市，如下图所示：![image.png](https://javacn.site/image/1648295837649-17ffae73-4342-4331-ada5-7041d33e9a01.png) 

这样改造之后，上面的表就满足第一范式了。

#### [#](#_2-第二范式) 2.第二范式

第二范式是在满足第一范式的基础上，规定表中的非主键列不存在对主键的部分依赖，也就是说每张表只描述一件事情，比如以下订单表就不满足第二范式，它可以拆分为两张独立的表：订单表和商品表。

#### [#](#_2-1-不满足第二范式的订单表) 2.1 不满足第二范式的订单表

![image.png](https://javacn.site/image/1648298009402-1c42c52c-3a46-4760-b1bf-1c99e57ff7b0.png)

> PS：上面的表可拆分为两张独立的表：订单表和商品表。

#### [#](#_2-2-满足第二范式的表) 2.2 满足第二范式的表

订单表： ![image.png](https://javacn.site/image/1648297941960-bd9764a5-f8c4-471d-96c7-42e9b81ab905.png) 商品表： ![image.png](https://javacn.site/image/1648298020290-a8874a2a-ea00-4548-86fe-4960fe96411c.png)

#### [#](#_3-第三范式) 3.第三范式

第三范式是在满足第一范式和第二范式的基础上，规定表中的列不存在对非主键列的传递依赖。比如以下的订单表中的顾客名称就不符合第三范式，因为它存在了对非主键顾客编号的依赖，如下图所示：![image.png](https://javacn.site/image/1648296977841-40b4cc30-2bec-4b61-b8bc-f330b443b003.png) 修改之后（符合第三范式）的表结构如下： ![image.png](https://javacn.site/image/1648297045480-9b719706-a411-47f6-bb19-c34cc3f24efe.png)

#### [#](#小结) 小结

第一范式规定表中的每个列都应该是不可分割的最小单元。第二范式是在满足第一范式的基础上，规定表中的非主键列不存在对主键的部分依赖。第三范式是在满足第一范式和第二范式的基础上，规定表中的列不存在对非主键列的传递依赖。使用数据库三范式的优势是：表的结构更简单、优雅，表的逻辑和条理性更强，并且使用三范式可以很大程度的减少表中的冗余数据，很好的节省了数据库的存储资源。

### 3.MySQL有哪些存储引擎？

MySQL 有很多数据引擎，也叫存储引擎，所谓的存储引擎是指用于存储、检索、更新和删除数据的服务。

在 MySQL 中可以使用“show engines”来查询数据库的所有存储引擎，如下图所示：![image.png](https://javacn.site/image/1651279782275-504eeaf8-b7bb-4c2d-b0e6-c52d40ae59dd.png)在上述列表中，我们最常用的存储引擎有以下 3 种：

1. InnoDB
2. MyISAM
3. MEMORY

下面我们分别来看。

#### [#](#_1-innodb) 1.InnoDB

InnoDB 是 MySQL 5.5 之后默认的存储引擎，它支持事务、支持外键、支持崩溃修复和自增列。如果对业务的完整性要求较高，比如张三给李四转账，需要减张三的钱，同时给李四加钱，这时候只能全部执行成功或全部执行失败，此时可以通过 InnoDB 来控制事务的提交和回滚，从而保证业务的完整性。

#### [#](#优缺点分析) 优缺点分析

InnoDB 的优势是支持事务、支持外键、支持崩溃修复和自增列；它的缺点是读写效率较差、占用的数据空间较大。

#### [#](#_2-myisam) 2.MyISAM

MyISAM 是 MySQL 5.5 之前默认的数据库引擎，读取效率较高，占用数据空间较少，但不支持事务、不支持行级锁、不支持外键等特性。因为不支持行级锁，因此在添加和修改操作时，会执行锁表操作，所以它的写入效率较低。

#### [#](#优缺点分析-1) 优缺点分析

MyISAM 引擎保存了单独的索引文件 .myi，且它的索引是直接定位到 OFFSET 的，而 InnoDB 没有单独的物理索引存储文件，且 InnoDB 索引寻址是先定位到块数据，再定位到行数据，所以 MyISAM 的查询效率是比 InnoDB 的查询效率要高。但它不支持事务、不支持外键，所以它的适用场景是读多写少，且对完整性要求不高的业务场景。

#### [#](#_3-memory) 3.MEMORY

内存型数据库引擎，所有的数据都存储在内存中，因此它的读写效率很高，但 MySQL 服务重启之后数据会丢失。它同样不支持事务、不支持外键。MEMORY 支持 Hash 索引或 B 树索引，其中 Hash 索引是基于 key 查询的，因此查询效率特别高，但如果是基于范围查询的效率就比较低了。而前面两种存储引擎是基于 B+ 树的数据结构实现了。

#### [#](#优缺点分析-2) 优缺点分析

MEMORY 读写性能很高，但 MySQL 服务重启之后数据会丢失，它不支持事务和外键。适用场景是读写效率要求高，但对数据丢失不敏感的业务场景。

#### [#](#_4-查看和设置存储引擎) 4.查看和设置存储引擎

#### [#](#_4-1-查看存储引擎) 4.1 查看存储引擎

存储引擎的设置粒度是表级别的，也就是每张表可以设置不同的存储引擎，我们可以使用以下命令来查询某张表的存储引擎：



```sql
show create table t;
```

如下图所示： ![image.png](https://javacn.site/image/1651281305965-96055bb3-c37b-4b34-994a-ac6ad182baf8.png)

#### [#](#_4-2-设置存储引擎) 4.2 设置存储引擎

在创建一张表的时候设置存储引擎： ![image.png](https://javacn.site/image/1651281618448-2940b146-2e82-40e6-abe2-55394d0ad379.png) 修改一张已经存在表的存储引擎：![image.png](https://javacn.site/image/1651281589885-672a6374-3682-499d-8644-b36bf68a9f15.png)

#### [#](#小结) 小结

MySQL 中最常见的存储引擎有：InnoDB、MyISAM 和 MEMORY，其中 InnoDB 是 MySQL 5.5 之后默认的存储引擎，它支持事务、支持外键、支持崩溃修复和自增列，它的特点是稳定（能保证业务的完整性），但数据的读写效率一般；而 MyISAM 的查询效率较高，但不支持事务和外键；MEMORY 的读写效率最高，但因为数据都保存在内存中的，所以 MySQL 服务重启之后数据就会丢失，因此它只适用于数据丢失不敏感的业务场景。

### 4.MyISAM和InnoDB有什么区别？

MyISAM 和 InnoDB 都是 MySQL 中最常用的两种存储引擎，在 MySQL 的官方文档中，可以看出二者的区别，官方说明链接如下：

1. InnoDB 引擎说明：[https://dev.mysql.com/doc/refman/8.0/en/innodb-introduction.htmlopen in new window](https://dev.mysql.com/doc/refman/8.0/en/innodb-introduction.html)
2. MyISAM 引擎说明：[https://dev.mysql.com/doc/refman/8.0/en/myisam-storage-engine.htmlopen in new window](https://dev.mysql.com/doc/refman/8.0/en/myisam-storage-engine.html)

考虑到便捷性和易读性我这里整合了一幅图，并将官方文档翻译成了中文，二者的区别如下：![image.png](https://javacn.site/image/1682157182555-e307d4ca-42e0-43a3-abd2-0332257ae0fc.png)从上面的对比图中我们可以看出，它们的区别主要体现在以下 7 点：

1. 事务支持不同：MyISAM 是非事务型存储引擎，它不支持事务操作；而 InnoDB 是事务型存储引擎，所以它是支持事务操作的，它可以保证数据的完整性和一致性。
2. 聚集索引的支持不同：MyISAM 不支持聚集索引，而 InnoDB 支持聚集索引。
3. 数据缓存支持不同：MyISAM 不支持数据缓存，而 InnoDB 支持数据缓存。
4. 外键支持不同：MyISAM 不支持外键，而 InnoDB 支持外键。
5. 锁粒度不同：InnoDB 支持行级锁定，可以对数据表的某行进行锁定，而不会锁定整个表，这样可以提高并发读写的能力；而 MyISAM 只支持表级锁定，只能对整个表进行锁定，这样容易造成大量的读写冲突和性能瓶颈。
6. 存储限制不同：MyISAM 支持 256TB 的数据存储，而 InnoDB 只支持 64TB 的数据存储。
7. MVCC 支持不同：MVCC （多版本并发控制）是一种数据库管理系统中的并发控制方法，它允许多个事务同时读取数据库中的同一数据，而不会相互干扰。MVCC通过为每个事务创建一个独立的“视图”来实现这一点，该视图显示了数据库在该事务开始时的状态。当事务读取数据时，它只能看到该视图中的数据，而不是实际的数据库状态。这意味着即使其他事务正在修改相同的数据，该事务也不会受到影响，因为它只能看到它开始时的数据状态。MyISAM 是不支持 MVCC 的，而 InnoDB 支持。

### 5.索引类型有哪些？

索引是一种数据结构，使用它可以快速的查询和检索数据。它可以看做是一本书的目录介绍，使用它可以快速地定位到需要查询的内容。 ![image.png](https://javacn.site/image/1682234465023-f76f7825-6db1-4fe4-a7d0-fe9c0606dcc7.png)

#### [#](#索引分类) 索引分类

索引一般可以分为以下几类：

1. 主键索引：主键索引是一种特殊的索引类型，它是用于唯一标识每一行数据的索引，每个表只能有一个主键索引。
2. 唯一索引：唯一索引是用来保证列的唯一性的索引，一个表可以有多个唯一索引。
3. 普通索引：普通索引也叫非唯一索引，它是最常见的一种索引类型，可以加速查询和排序操作。
4. 全文索引：全文索引是一种用于全文搜索的索引类型，能够对文本数据进行快速的模糊搜索和关键字搜索。
5. 复合索引：复合索引也叫多列索引或联合索引，它是包含多个列的索引类型，能够加速多列查询和排序操作。
6. 哈希索引：哈希索引是基于哈希表实现的索引类型，能够对等值查询进行高效的处理，但不支持范围查询和排序，MySQL 中 Memory 引擎中支持哈希索引。

#### [#](#优缺点分析) 优缺点分析

索引的主要优点如下：

1. 提高查询效率：索引可以加速数据的检索速度，对于大量数据的表而言，使用索引可以大幅提高查询效率。
2. 避免全表扫描：当没有索引时，数据库会进行全表扫描，而索引可以帮助避免全表扫描，加速查询。
3. 增强数据的唯一性和完整性：可以通过在列上创建唯一索引和主键索引来确保表中的数据唯一性和完整性。

索引的缺点如下：

1. 占用额外存储空间：每个索引都会占用额外的存储空间，因此在设计索引时需要权衡存储空间和查询效率之间的平衡。
2. 降低写操作效率：索引的维护需要额外的写操作，因此在大量写操作的情况下可能会降低写操作的效率。
3. 可能出现索引失效：索引并不是万能的，有些情况下使用索引可能会导致查询效率降低甚至出现索引失效的情况。例如，当对于一个非常小的表或者一个稠密的索引列进行查询时，使用索引可能并不会提高查询效率。
4. 索引需要维护：随着表数据的不断变化，索引也需要不断维护以保持其效率。因此，在使用索引时需要注意索引的维护成本。

#### [#](#应用场景) 应用场景

适合创建索引的场景有以下几个：

1. 频繁用于条件查询的列：如果一个列经常用于 WHERE、JOIN、ORDER BY 或 GROUP BY 子句中，那么可以考虑在该列上创建索引。
2. 唯一性约束：对于需要保证唯一性的列，应该在该列上创建唯一索引或主键索引。
3. 经常用于排序的列：对于需要经常进行排序的列，如 ORDER BY 子句中的列，应该在该列上创建索引。
4. 经常用于聚合函数的列：对于经常用于聚合函数（如 COUNT、AVG、SUM、MIN、MAX）的列，应该在该列上创建索引，可以加速聚合查询。

虽然索引可以提高查询效率，但有些情况下并不适合使用索引，比如以下这些：

1. 对于小表：如果表的数据量比较小，那么建立索引并不能带来很大的性能提升，反而会增加查询时间和占用存储空间。
2. 对于多写少读的表：索引会增加写操作的时间，并占用更多的存储空间，因此对于频繁进行 INSERT、UPDATE 或 DELETE 操作的表，不宜过多地建立索引。

总之，创建索引需要根据具体的情况进行权衡和取舍，只有在真正需要提高查询效率时才应该创建索引，否则会浪费存储空间和增加写操作的时间。









